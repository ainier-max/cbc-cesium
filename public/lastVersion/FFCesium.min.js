import * as e from "cesium";
import * as i from "@turf/turf";
import { nextTick as n } from "vue";
import o from "cesium-navigation-es6";
const r = {
    addGaodeLayer(t) {
      var i = new e.UrlTemplateImageryProvider({ url: t });
      return this.viewer.imageryLayers.addImageryProvider(i), i;
    },
    addTdtVecLayer() {
      return this.addTdtLayer(
        "https://t4.tianditu.gov.cn/vec_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=vec&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&tk=2cf56b2e77c1be9a456ef411d808daad"
      );
    },
    addTdtCvaLayer() {
      return this.addTdtLayer(
        "https://t4.tianditu.gov.cn/cva_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cva&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&tk=2cf56b2e77c1be9a456ef411d808daad"
      );
    },
    addTdtImgLayer() {
      return this.addTdtLayer(
        "https://t4.tianditu.gov.cn/img_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=img&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&tk=2cf56b2e77c1be9a456ef411d808daad"
      );
    },
    addTdtCiaLayer() {
      return this.addTdtLayer(
        "https://t4.tianditu.gov.cn/cia_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cia&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&tk=2cf56b2e77c1be9a456ef411d808daad"
      );
    },
    addTdtCtaLayer() {
      return this.addTdtLayer(
        "https://t4.tianditu.gov.cn/cta_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cta&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&tk=2cf56b2e77c1be9a456ef411d808daad"
      );
    },
    addTdtLayer(t) {
      var i = { url: t },
        n = new e.UrlTemplateImageryProvider(i);
      return this.viewer.imageryLayers.addImageryProvider(n);
    },
    addArcgisImgLayer() {
      return this.addCustomLayer(
        "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}"
      );
    },
    addCustomLayer(t) {
      var i = { url: t },
        n = new e.UrlTemplateImageryProvider(i);
      return this.viewer.imageryLayers.addImageryProvider(n);
    },
    removeMapLayer(e) {
      this.viewer.imageryLayers.remove(e, !0);
    },
    hideMapLayer() {},
  },
  a = {
    async addObliquePhotography(t, i) {
      try {
        const n = await e.Cesium3DTileset.fromUrl(t, i);
        return this.viewer.scene.primitives.add(n), n;
      } catch (e) {}
    },
    removeObliquePhotography(e) {
      this.viewer.scene.primitives.remove(e);
    },
    async addTerrain(t) {
      try {
        var i = await e.CesiumTerrainProvider.fromUrl(t, {});
        return (this.viewer.scene.terrainProvider = i), i;
      } catch (e) {}
    },
    removeTerrain() {
      this.viewer.scene.terrainProvider = new e.EllipsoidTerrainProvider();
    },
    readGeojson: (t) => e.GeoJsonDataSource.load(t),
    addGeojson(t, i) {
      return (
        this.viewer.dataSources.add(t),
        (i.stroke = e.Color.fromCssColorString(i.stroke)),
        (i.fill = e.Color.fromCssColorString(i.fill).withAlpha(i.fillAlpha)),
        t.entities.values.forEach(function (e) {
          e.polygon &&
            ((e.polygon.outline = !1),
            (e.polygon.material = i.fill),
            (e.polyline = {
              positions: e.polygon.hierarchy._value.positions,
              width: i.strokeWidth,
              material: i.stroke,
            }));
        }),
        t
      );
    },
    readKml(t) {
      return e.KmlDataSource.load(t, {
        camera: this.viewer.scene.camera,
        canvas: this.viewer.scene.canvas,
        screenOverlayContainer: this.viewer.container,
      });
    },
    addKml(e) {
      return this.viewer.dataSources.add(e), e;
    },
    removeDataSource(e) {
      this.viewer.dataSources.remove(e);
    },
    addWmslayer(t, i) {
      var n = new e.WebMapServiceImageryProvider({
        url: t,
        layers: i,
        parameters: {
          transparent: !0,
          service: "WMS",
          format: "image/png",
          srs: "EPSG:4326",
        },
      });
      return this.viewer.imageryLayers.addImageryProvider(n);
    },
    findWmsLayer(t) {
      let i = new e.WebMapServiceImageryProvider(t);
      return this.viewer.imageryLayers.addImageryProvider(i);
    },
  },
  l = e.BoxGeometry,
  s = e.Cartesian3,
  c = e.defaultValue,
  h = e.defined,
  d = e.destroyObject,
  p = e.DeveloperError,
  u = e.GeometryPipeline,
  g = e.Matrix3,
  m = e.Matrix4,
  v = e.Transforms,
  y = e.VertexFormat,
  f = e.BufferUsage,
  C = e.CubeMap,
  P = e.DrawCommand,
  A = e.loadCubeMap,
  w = e.RenderState,
  F = e.VertexArray,
  E = e.BlendingState,
  T = e.SceneMode,
  I = e.ShaderProgram,
  S = e.ShaderSource;
function L(e) {
  (this.sources = e.sources),
    (this._sources = void 0),
    (this.show = c(e.show, !0)),
    (this._command = new P({ modelMatrix: m.clone(m.IDENTITY), owner: this })),
    (this._cubeMap = void 0),
    (this._attributeLocations = void 0),
    (this._useHdr = void 0);
}
e.defined(e.Matrix4.getRotation) ||
  (e.Matrix4.getRotation = e.Matrix4.getMatrix3);
const M = new g();
(L.prototype.update = function (e, t) {
  const i = this;
  if (!this.show) return;
  if (e.mode !== T.SCENE3D && e.mode !== T.MORPHING) return;
  if (!e.passes.render) return;
  const n = e.context;
  if (this._sources !== this.sources) {
    this._sources = this.sources;
    const e = this.sources;
    if (
      !(
        h(e.positiveX) &&
        h(e.negativeX) &&
        h(e.positiveY) &&
        h(e.negativeY) &&
        h(e.positiveZ) &&
        h(e.negativeZ)
      )
    )
      throw new p(
        "this.sources is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties."
      );
    if (
      typeof e.positiveX != typeof e.negativeX ||
      typeof e.positiveX != typeof e.positiveY ||
      typeof e.positiveX != typeof e.negativeY ||
      typeof e.positiveX != typeof e.positiveZ ||
      typeof e.positiveX != typeof e.negativeZ
    )
      throw new p("this.sources properties must all be the same type.");
    "string" == typeof e.positiveX
      ? A(n, this._sources).then(function (e) {
          (i._cubeMap = i._cubeMap && i._cubeMap.destroy()), (i._cubeMap = e);
        })
      : ((this._cubeMap = this._cubeMap && this._cubeMap.destroy()),
        (this._cubeMap = new C({ context: n, source: e })));
  }
  const o = this._command;
  if (
    ((o.modelMatrix = v.eastNorthUpToFixedFrame(e.camera._positionWC)),
    !h(o.vertexArray))
  ) {
    o.uniformMap = {
      u_cubeMap: function () {
        return i._cubeMap;
      },
      u_rotateMatrix: function () {
        return m.getRotation(o.modelMatrix, M);
      },
    };
    const e = l.createGeometry(
        l.fromDimensions({
          dimensions: new s(2, 2, 2),
          vertexFormat: y.POSITION_ONLY,
        })
      ),
      t = (this._attributeLocations = u.createAttributeLocations(e));
    (o.vertexArray = F.fromGeometry({
      context: n,
      geometry: e,
      attributeLocations: t,
      bufferUsage: f._DRAW,
    })),
      (o.renderState = w.fromCache({ blending: E.ALPHA_BLEND }));
  }
  if (!h(o.shaderProgram) || this._useHdr !== t) {
    const e = new S({
      defines: [t ? "HDR" : ""],
      sources: [
        "uniform samplerCube u_cubeMap;\n  varying vec3 v_texCoord;\n  void main()\n  {\n  vec4 color = textureCube(u_cubeMap, normalize(v_texCoord));\n  gl_FragColor = vec4(czm_gammaCorrect(color).rgb, czm_morphTime);\n  }\n  ",
      ],
    });
    (o.shaderProgram = I.fromCache({
      context: n,
      vertexShaderSource:
        "attribute vec3 position;\n  varying vec3 v_texCoord;\n  uniform mat3 u_rotateMatrix;\n  void main()\n  {\n  vec3 p = czm_viewRotation * u_rotateMatrix * (czm_temeToPseudoFixed * (czm_entireFrustum.y * position));\n  gl_Position = czm_projection * vec4(p, 1.0);\n  v_texCoord = position.xyz;\n  }\n  ",
      fragmentShaderSource: e,
      attributeLocations: this._attributeLocations,
    })),
      (this._useHdr = t);
  }
  return h(this._cubeMap) ? o : void 0;
}),
  (L.prototype.isDestroyed = function () {
    return !1;
  }),
  (L.prototype.destroy = function () {
    const e = this._command;
    return (
      (e.vertexArray = e.vertexArray && e.vertexArray.destroy()),
      (e.shaderProgram = e.shaderProgram && e.shaderProgram.destroy()),
      (this._cubeMap = this._cubeMap && this._cubeMap.destroy()),
      d(this)
    );
  });
const b = {
    measureLineLengthEntitys: [],
    measureLineLengthHandler: null,
    measureAreaSpaceEntitys: [],
    measureAreaSpaceHandler: null,
    cesiumNavigation: null,
    openMapInfoHtmlOverlay: null,
    addSkyBox(e) {
      const t = new L({
        sources: {
          positiveX: e.px,
          negativeX: e.nx,
          positiveY: e.py,
          negativeY: e.ny,
          positiveZ: e.pz,
          negativeZ: e.nz,
        },
      });
      (this.viewer.scene.skyBox = t),
        (this.viewer.scene.skyAtmosphere.show = !1);
    },
    removeSkyBox() {
      (this.viewer.scene.skyBox = this.viewer.defaultSkybox),
        (this.viewer.scene.skyAtmosphere.show = !0);
    },
    cartesian3ToLngLat(t) {
      let i = this.viewer.scene.globe.ellipsoid.cartesianToCartographic(t);
      return {
        lat: e.Math.toDegrees(i.latitude),
        lng: e.Math.toDegrees(i.longitude),
        height: i.height,
      };
    },
    lngLatToCartesian3: (t) => (
      t.height || (t.height = 0),
      e.Cartesian3.fromDegrees(t.lng, t.lat, t.height)
    ),
    openMapInfo(t) {
      if (!this.openMapInfoHtmlOverlay) {
        let e = document.getElementById(this.cesiumID);
        (this.openMapInfoHtmlOverlay = document.createElement("div")),
          (this.openMapInfoHtmlOverlay.style.zIndex = 100),
          (this.openMapInfoHtmlOverlay.style.position = "absolute"),
          (this.openMapInfoHtmlOverlay.innerHTML =
            "经度：<span id='openMapInfoLng'>0</span> , 纬度：<span id='openMapInfoLat'>0</span>"),
          e.appendChild(this.openMapInfoHtmlOverlay);
      }
      for (let e in t) this.openMapInfoHtmlOverlay.style[e] = t[e];
      this.openMapInfoHtmlOverlay.style.display = "block";
      let i = this;
      var n = this.viewer.scene.globe.ellipsoid;
      new e.ScreenSpaceEventHandler(this.viewer.canvas).setInputAction(
        function (t) {
          var o = i.viewer.camera.pickEllipsoid(t.endPosition, n);
          if (o) {
            var r = i.viewer.scene.globe.ellipsoid.cartesianToCartographic(o),
              a = e.Math.toDegrees(r.latitude),
              l = e.Math.toDegrees(r.longitude);
            void 0 !== a &&
              void 0 !== l &&
              ((document.getElementById("openMapInfoLng").innerHTML =
                l.toFixed(4)),
              (document.getElementById("openMapInfoLat").innerHTML =
                a.toFixed(4)));
          }
        },
        e.ScreenSpaceEventType.MOUSE_MOVE
      );
    },
    closeMapInfo() {
      this.openMapInfoHtmlOverlay.style.display = "none";
    },
    measureLineLength(t) {
      let i = 0,
        n = [],
        o = null;
      (this.measureLineLengthHandler = new e.ScreenSpaceEventHandler(
        this.viewer.canvas
      )),
        (document.getElementById(this.cesiumID).style.cursor = "crosshair");
      let r = this;
      this.measureLineLengthHandler.setInputAction(function (t) {
        let a = r.viewer.camera.getPickRay(t.position),
          l = r.viewer.scene.globe.pick(a, r.viewer.scene);
        if (!e.defined(l)) return;
        let s = r.viewer.entities.add({
          name: "polyline_point",
          position: l,
          point: {
            color: e.Color.WHITE,
            pixelSize: 5,
            heightReference: e.HeightReference.CLAMP_TO_GROUND,
            outlineColor: e.Color.BLACK,
            outlineWidth: 1,
          },
        });
        if ((r.measureLineLengthEntitys.push(s), n.push(l), n.length >= 2)) {
          null == o &&
            ((o = r.viewer.entities.add({
              polyline: {
                positions: new e.CallbackProperty(function (e, t) {
                  return n;
                }, !1),
                width: 10,
                clampToGround: !0,
                material: new e.PolylineGlowMaterialProperty({
                  color: e.Color.CHARTREUSE.withAlpha(0.5),
                }),
              },
            })),
            r.measureLineLengthEntitys.push(o));
          var c = e.Cartesian3.distance(n[n.length - 2], n[n.length - 1]);
          i += c;
          let t = "";
          t = c > 1e4 ? (c / 1e3).toFixed(2) + "km" : c.toFixed(2) + "m";
          let a = r.measureCenterByCartesian(n[n.length - 2], n[n.length - 1]),
            l = r.viewer.entities.add({
              position: a,
              label: {
                text: t,
                font: "18px sans-serif",
                fillColor: e.Color.GOLD,
                style: e.LabelStyle.FILL_AND_OUTLINE,
                outlineWidth: 2,
                verticalOrigin: e.VerticalOrigin.BOTTOM,
              },
            });
          r.measureLineLengthEntitys.push(l);
        }
      }, e.ScreenSpaceEventType.LEFT_CLICK),
        this.measureLineLengthHandler.setInputAction(function (n) {
          (document.getElementById(r.cesiumID).style.cursor = "default"),
            r.measureLineLengthHandler.removeInputAction(
              e.ScreenSpaceEventType.LEFT_CLICK
            ),
            r.measureLineLengthHandler.removeInputAction(
              e.ScreenSpaceEventType.RIGHT_CLICK
            ),
            t(i);
        }, e.ScreenSpaceEventType.RIGHT_CLICK);
    },
    clearMeasureLineLengthEntitys() {
      (document.getElementById(this.cesiumID).style.cursor = "default"),
        this.measureLineLengthHandler.removeInputAction(
          e.ScreenSpaceEventType.LEFT_CLICK
        ),
        this.measureLineLengthHandler.removeInputAction(
          e.ScreenSpaceEventType.RIGHT_CLICK
        ),
        this.measureLineLengthEntitys.forEach((e) => {
          this.viewer.entities.remove(e);
        }),
        (this.measureLineLengthEntitys = []);
    },
    measureCenterByCartesian(t, i) {
      var n = e.Ellipsoid.WGS84.cartesianToCartographic(t),
        o = e.Ellipsoid.WGS84.cartesianToCartographic(i),
        r = (n.longitude + o.longitude) / 2,
        a = (n.latitude + o.latitude) / 2,
        l = e.Cartographic.fromRadians(r, a);
      return e.Ellipsoid.WGS84.cartographicToCartesian(l);
    },
    measureAreaSpace(t) {
      var n = [],
        o = null;
      (this.measureAreaSpaceHandler = new e.ScreenSpaceEventHandler(
        this.viewer.scene.canvas
      )),
        (document.getElementById(this.cesiumID).style.cursor = "crosshair");
      let r = this;
      this.measureAreaSpaceHandler.setInputAction((t) => {
        var i = r.viewer.camera.getPickRay(t.position),
          a = r.viewer.scene.globe.pick(i, r.viewer.scene);
        if (e.defined(a)) {
          var l = r.viewer.entities.add({
            position: a,
            point: {
              color: e.Color.WHITE,
              pixelSize: 5,
              heightReference: e.HeightReference.CLAMP_TO_GROUND,
              outlineColor: e.Color.BLACK,
              outlineWidth: 1,
            },
          });
          r.measureAreaSpaceEntitys.push(l),
            n.push(a),
            n.length >= 3 &&
              (null == o
                ? ((o = r.viewer.entities.add({
                    polygon: {
                      hierarchy: new e.CallbackProperty(function (t, i) {
                        return new e.PolygonHierarchy(n, null);
                      }, !1),
                      material: e.Color.GREENYELLOW.withAlpha(0.5),
                    },
                  })),
                  r.measureAreaSpaceEntitys.push(o))
                : (o.polygon.hierarchy = new e.CallbackProperty(function (
                    t,
                    i
                  ) {
                    return new e.PolygonHierarchy(n, null);
                  },
                  !1)));
        }
      }, e.ScreenSpaceEventType.LEFT_CLICK),
        this.measureAreaSpaceHandler.setInputAction(function (n) {
          var a = o.polygon.hierarchy.getValue().positions;
          if (a.length >= 3) {
            for (var l = [], s = 0; s < a.length; s++) {
              var c = r.viewer.scene.globe.ellipsoid,
                h = new e.Cartesian3(a[s].x, a[s].y, a[s].z),
                d = c.cartesianToCartographic(h),
                p = {};
              (p.lat = e.Math.toDegrees(d.latitude)),
                (p.lng = e.Math.toDegrees(d.longitude)),
                l.push(p);
            }
            let n = [],
              o = [];
            l.forEach((e, t) => {
              n.push(i.point([e.lng, e.lat])), o.push([e.lng, e.lat]);
            });
            var u = i.featureCollection(n),
              g = i.center(u);
            let y = g.geometry.coordinates[0],
              f = g.geometry.coordinates[1];
            o.push(o[0]);
            var m = i.polygon([o]),
              v = i.area(m);
            let C = "";
            C = v > 1e4 ? (v / 1e6).toFixed(2) + "k㎡" : v.toFixed(2) + "㎡";
            let P = r.viewer.entities.add({
              position: e.Cartesian3.fromDegrees(y, f),
              label: {
                text: C,
                font: "18px sans-serif",
                fillColor: e.Color.GOLD,
                style: e.LabelStyle.FILL_AND_OUTLINE,
                outlineWidth: 2,
                verticalOrigin: e.VerticalOrigin.BOTTOM,
              },
            });
            r.measureAreaSpaceEntitys.push(P),
              (document.getElementById(r.cesiumID).style.cursor = "default"),
              r.measureAreaSpaceHandler.removeInputAction(
                e.ScreenSpaceEventType.LEFT_CLICK
              ),
              r.measureAreaSpaceHandler.removeInputAction(
                e.ScreenSpaceEventType.RIGHT_CLICK
              ),
              t(v);
          } else this.clearMeasureAreaSpaceEntitys();
        }, e.ScreenSpaceEventType.RIGHT_CLICK);
    },
    clearMeasureAreaSpaceEntitys() {
      (document.getElementById(this.cesiumID).style.cursor = "default"),
        this.measureAreaSpaceHandler.removeInputAction(
          e.ScreenSpaceEventType.LEFT_CLICK
        ),
        this.measureAreaSpaceHandler.removeInputAction(
          e.ScreenSpaceEventType.RIGHT_CLICK
        ),
        this.measureAreaSpaceEntitys.forEach((e) => {
          this.viewer.entities.remove(e);
        }),
        (this.measureAreaSpaceEntitys = []);
    },
    openCompassTool(e) {
      this.cesiumNavigation ||
        (this.cesiumNavigation = new o(this.viewer, {
          enableCompass: !0,
          enableZoomControls: !1,
          enableDistanceLegend: !1,
        }));
      const t = document.getElementsByClassName("compass");
      t[0].style.display = "none";
      for (let i in e) t[0].style[i] = e[i];
      n(() => {
        t[0].style.display = "block";
      });
    },
    closeCompassTool() {
      if (this.cesiumNavigation) {
        document.getElementsByClassName("compass")[0].style.display = "none";
      }
    },
    openScaleTool(e) {
      this.cesiumNavigation ||
        (this.cesiumNavigation = new o(this.viewer, {
          enableCompass: !1,
          enableZoomControls: !1,
          enableDistanceLegend: !0,
        }));
      const t = document.getElementsByClassName("distance-legend");
      t[0].style.display = "none";
      for (let i in e) t[0].style[i] = e[i];
      document.getElementsByClassName("distance-legend-label")[0].style.color =
        "#000000";
      const i = document.getElementsByClassName("distance-legend-scale-bar");
      (i[0].style.borderLeft = "1px solid #000000"),
        (i[0].style.borderRight = "1px solid #000000"),
        (i[0].style.borderBottom = "1px solid #000000"),
        n(() => {
          t[0].style.display = "block";
        });
    },
    closeScaleTool() {
      if (this.cesiumNavigation) {
        document.getElementsByClassName("distance-legend")[0].style.display =
          "none";
      }
    },
    openMouseTipHandler: null,
    openMouseTipLabelEntity: null,
    openMouseTipLabel: "",
    openMouseTip(t) {
      (this.openMouseTipLabel = t), this.closeMouseTip();
      let i = this;
      (this.openMouseTipHandler = new e.ScreenSpaceEventHandler(
        i.viewer.scene.canvas
      )),
        this.openMouseTipHandler.setInputAction(function (t) {
          var n = t.endPosition,
            o = i.viewer.camera.getPickRay(n),
            r = i.viewer.scene.globe.pick(o, i.viewer.scene);
          e.defined(r) &&
            (i.openMouseTipLabelEntity
              ? ((i.openMouseTipLabelEntity.position = r),
                (i.openMouseTipLabelEntity.label.text = i.openMouseTipLabel))
              : (i.openMouseTipLabelEntity = i.viewer.entities.add({
                  position: r,
                  label: {
                    text: i.openMouseTipLabel,
                    font: "14px 宋体",
                    showBackground: !0,
                    pixelOffset: new e.Cartesian2(0, 20),
                    backgroundColor: new e.Color.fromCssColorString(
                      "#4CAF50"
                    ).withAlpha(1),
                  },
                })));
        }, e.ScreenSpaceEventType.MOUSE_MOVE);
    },
    closeMouseTip() {
      this.openMouseTipHandler &&
        (this.openMouseTipHandler.destroy(), (this.openMouseTipHandler = null)),
        this.openMouseTipLabelEntity &&
          (this.viewer.entities.remove(this.openMouseTipLabelEntity),
          (this.openMouseTipLabelEntity = null));
    },
    updateMouseTip(e) {
      (this.openMouseTipLabel = e),
        this.openMouseTipLabelEntity &&
          (this.openMouseTipLabelEntity.label.text = this.openMouseTipLabel);
    },
  },
  D = {
    ffCesiumPointPrimitiveCollection: null,
    ffCesiumPrimitiveCollection: null,
    ffCesiumBillboardPrimitiveCollection: null,
    ffCesiumGltfCollection: null,
    addPrimitiveInit() {
      (this.ffCesiumPointPrimitiveCollection = this.viewer.scene.primitives.add(
        new e.PointPrimitiveCollection()
      )),
        (this.ffCesiumPrimitiveCollection = this.viewer.scene.primitives.add(
          new e.PrimitiveCollection()
        )),
        (this.ffCesiumGltfCollection = this.viewer.scene.primitives.add(
          new e.PrimitiveCollection()
        )),
        (this.ffCesiumBillboardPrimitiveCollection =
          this.viewer.scene.primitives.add(new e.BillboardCollection()));
    },
    async addGltfPrimitive(t, i) {
      const n = e.Cartesian3.fromDegrees(t[0], t[1], t[2]);
      let o = e.Math.toRadians(i.headingAngle),
        r = e.Math.toRadians(i.pitchAngle),
        a = e.Math.toRadians(i.rollAngle),
        l = new e.HeadingPitchRoll(o, r, a);
      const s = e.Transforms.localFrameToFixedFrameGenerator("north", "west");
      try {
        const t = await e.Model.fromGltfAsync({
          url: i.url,
          modelMatrix: e.Transforms.headingPitchRollToFixedFrame(
            n,
            l,
            e.Ellipsoid.WGS84,
            s
          ),
          minimumPixelSize: i.minimumPixelSize,
          maximumScale: i.maximumScale,
        });
        return (
          (t.FFtype = "FFGltfPrimitive"), this.ffCesiumGltfCollection.add(t), t
        );
      } catch (e) {}
    },
    addBillboardPrimitive(t, i) {
      let n = Object.assign({}, i);
      (n.position = e.Cartesian3.fromDegrees(t[0], t[1], t[2])),
        (n.image = n.image),
        (n.pixelOffset = new e.Cartesian2(n.pixelOffset[0], n.pixelOffset[1]));
      let o = this.ffCesiumBillboardPrimitiveCollection.add(n);
      return (o.FFtype = "FFBillboardPrimitive"), o;
    },
    addPointPrimitive(t, i) {
      let n = Object.assign({}, i);
      (n.position = e.Cartesian3.fromDegrees(t[0], t[1], t[2])),
        (n.color = new e.Color.fromCssColorString(i.color).withAlpha(i.alpha)),
        i.outlineColor &&
          (n.outlineColor = new e.Color.fromCssColorString(i.outlineColor));
      let o = this.ffCesiumPointPrimitiveCollection.add(n);
      return (o.FFtype = "FFPointPrimitive"), o;
    },
    addPolylinePrimitive(t, i) {
      let n = e.Cartesian3.fromDegreesArrayHeights(t.flat());
      const o = new e.GeometryInstance({
          geometry: new e.PolylineGeometry({ positions: n, width: i.width }),
        }),
        r = new e.Primitive({
          geometryInstances: o,
          appearance: new e.PolylineMaterialAppearance({
            material: new e.Material({
              fabric: {
                type: "Color",
                uniforms: {
                  color: new e.Color.fromCssColorString(i.color).withAlpha(
                    i.alpha
                  ),
                },
              },
            }),
          }),
        });
      return (
        this.ffCesiumPrimitiveCollection.add(r),
        (r.FFOption = i),
        (r.FFtype = "FFPolylinePrimitive"),
        (r.FFLngLatHeightArr = t),
        (r.FFPosition = n),
        r
      );
    },
    addPolygonPrimitive(t, i) {
      const n = new e.GeometryInstance({
          geometry: new e.PolygonGeometry({
            polygonHierarchy: new e.PolygonHierarchy(
              e.Cartesian3.fromDegreesArray(t.flat())
            ),
          }),
        }),
        o = new e.Primitive({
          geometryInstances: n,
          appearance: new e.MaterialAppearance({
            material: new e.Material({
              fabric: {
                type: "Color",
                uniforms: {
                  color: new e.Color.fromCssColorString(i.color).withAlpha(
                    i.alpha
                  ),
                },
              },
            }),
          }),
        });
      return (
        this.ffCesiumPrimitiveCollection.add(o),
        (o.FFtype = "FFPolygonPrimitive"),
        o
      );
    },
    removeFFPrimitive(e) {
      e.FFtype &&
        ("FFPointPrimitive" == e.FFtype
          ? this.ffCesiumPointPrimitiveCollection.remove(e)
          : "FFBillboardPrimitive" == e.FFtype
          ? this.ffCesiumBillboardPrimitiveCollection.remove(e)
          : "FFGltfPrimitive" == e.FFtype
          ? this.ffCesiumGltfCollection.remove(e)
          : ("FFPolylinePrimitive" != e.FFtype &&
              "FFPolygonPrimitive" != e.FFtype) ||
            this.ffCesiumPrimitiveCollection.remove(e));
    },
  },
  H = {
    removeFFEntity(e) {
      this.viewer.entities.remove(e);
    },
    removeFFEntityArr(e) {
      e.forEach((e) => {
        this.viewer.entities.remove(e);
      });
    },
    removeFFEntityID(e) {
      this.viewer.entities.removeById(e);
    },
    removeFFEntityIDArr(e) {
      e.forEach((e) => {
        this.viewer.entities.removeById(e);
      });
    },
    addCircleEntity(t, i, n) {
      let o = Object.assign({}, n);
      (o.semiMinorAxis = i),
        (o.semiMajorAxis = i),
        (o.material = new e.Color.fromCssColorString(o.color).withAlpha(
          o.alpha
        ));
      let r = e.Cartesian3.fromDegrees(t[0], t[1], t[2]),
        a = { position: r, ellipse: { ...o } };
      o.id && (a.id = o.id);
      let l = this.viewer.entities.add(a);
      return (
        (l.FFOption = n),
        (l.FFType = "FFCircleEntity"),
        (l.FFCenterPoint = t),
        (l.FFRadius = i),
        (l.FFPosition = r),
        l
      );
    },
    addPointEntity(t, i) {
      let n = Object.assign({}, i),
        o = e.Cartesian3.fromDegrees(t[0], t[1], t[2]);
      (n.color = new e.Color.fromCssColorString(i.color).withAlpha(i.alpha)),
        i.outlineColor &&
          (n.outlineColor = new e.Color.fromCssColorString(i.outlineColor));
      let r = { position: o, point: { ...n } };
      n.id && (r.id = n.id);
      let a = this.viewer.entities.add(r);
      return (
        (a.FFOption = i),
        (a.FFType = "FFPointEntity"),
        (a.FFCoordinates = t),
        (a.FFPosition = o),
        a
      );
    },
    addBillboardEntity(t, i) {
      let n = Object.assign({}, i),
        o = null;
      (o = i.heightReference
        ? e.Cartesian3.fromDegrees(t[0], t[1])
        : e.Cartesian3.fromDegrees(t[0], t[1], t[2])),
        (n.pixelOffset = new e.Cartesian2(n.pixelOffset[0], n.pixelOffset[1]));
      let r = { position: o, billboard: { ...n } };
      n.id && (r.id = n.id);
      let a = this.viewer.entities.add(r);
      return (
        (a.FFOption = i),
        (a.FFType = "FFBillboardEntity"),
        (a.FFCoordinates = t),
        (a.FFPosition = o),
        a
      );
    },
    addRectangleEntity(t, i) {
      let n = Object.assign({}, i),
        o = e.Rectangle.fromDegrees(t.west, t.south, t.east, t.north),
        r = {
          rectangle: {
            coordinates: o,
            material: new e.Color.fromCssColorString(n.color).withAlpha(
              n.alpha
            ),
            ...n,
          },
        };
      n.id && (r.id = n.id);
      let a = this.viewer.entities.add(r);
      return (
        (a.FFOption = i),
        (a.FFType = "FFRectangleEntity"),
        (a.FFCoordinates = t),
        (a.FFPosition = o),
        a
      );
    },
    addPolygonEntity(t, i) {
      let n = Object.assign({}, i);
      t.length > 0 &&
        t[0].length > 2 &&
        (t = this.getLngLatArrFromLngLatHeightArr(t));
      let o = e.Cartesian3.fromDegreesArray(t.flat()),
        r = {
          polygon: {
            hierarchy: o,
            material: new e.Color.fromCssColorString(n.color).withAlpha(
              n.alpha
            ),
            ...n,
          },
        };
      n.id && (r.id = n.id);
      let a = this.viewer.entities.add(r);
      return (
        (a.FFOption = i),
        (a.FFType = "FFPolygonEntity"),
        (a.FFCoordinates = t),
        (a.FFPosition = o),
        a
      );
    },
    addPolylineEntity(t, i) {
      let n = Object.assign({}, i),
        o = e.Cartesian3.fromDegreesArrayHeights(t.flat()),
        r = {
          polyline: {
            positions: o,
            material: new e.Color.fromCssColorString(n.color).withAlpha(
              n.alpha
            ),
            ...n,
          },
        };
      n.id && (r.id = n.id);
      let a = this.viewer.entities.add(r);
      return (
        (a.FFOption = i),
        (a.FFType = "FFPolylineEntity"),
        (a.FFCoordinates = t),
        (a.FFPosition = o),
        a
      );
    },
  },
  _ = {
    flyTo(t, i) {
      let n = this,
        o = [e.Cartographic.fromDegrees(t.lng, t.lat)];
      (o.option = t),
        e.sampleTerrain(n.viewer.scene.terrainProvider, 14, o).then((o) => {
          o.option.height = o[0].height;
          let r = new e.Entity({
            position: e.Cartesian3.fromDegrees(
              o.option.lng,
              o.option.lat,
              o.option.height
            ),
            point: {
              pixelSize: 1,
              color: e.Color.RED.withAlpha(0.9),
              outlineColor: e.Color.WHITE.withAlpha(0.9),
              outlineWidth: 0,
            },
          });
          n.viewer.entities.add(r),
            n.viewer
              .flyTo(r, {
                duration: t.time,
                offset: {
                  heading: e.Math.toRadians(0),
                  pitch: e.Math.toRadians(o.option.pitchRadiu),
                  range: o.option.eyeHeight,
                },
              })
              .then(function () {
                n.viewer.entities.remove(r), (r = null), i && i();
              });
        });
    },
    setView(t) {
      this.viewer.camera.setView({
        destination: e.Cartesian3.fromDegrees(t.lng, t.lat, t.height),
        orientation: {
          heading: e.Math.toRadians(0, 0),
          pitch: e.Math.toRadians(t.pitchRadiu),
          roll: 0,
        },
      });
    },
  },
  R = {
    addHtml(t, i, n) {
      let o = document.createElement("div");
      (o.style.zIndex = n.zIndex),
        (o.style.position = "absolute"),
        (o.style.display = "none"),
        (o.innerHTML = i),
        document.getElementById(this.cesiumID).appendChild(o);
      var r = new e.Cartesian2();
      let a = this;
      return (
        this.viewer.scene.preRender.addEventListener(function () {
          var i = e.Cartesian3.fromDegrees(t[0], t[1], t[2]),
            l = a.viewer.scene.cartesianToCanvasCoordinates(i, r);
          if (e.defined(l)) {
            let e = o.offsetHeight + n.offset.top,
              t = o.offsetWidth / 2 + n.offset.left;
            (o.style.top = l.y - e + "px"), (o.style.left = l.x - t + "px");
          }
          "none" == o.style.display &&
            window.setTimeout(() => {
              o.style.display = "block";
            }, 50);
        }),
        o
      );
    },
    removeHtml(e) {
      try {
        document.getElementById(this.cesiumID).removeChild(e);
      } catch (e) {}
    },
  },
  k = {
    gatherHandler: null,
    gatherHandlerDestroy() {
      this.gatherHandler &&
        (this.gatherHandler.destroy(), (this.gatherHandler = null));
    },
    circleGather(t, i) {
      let n = this;
      n.gatherHandlerDestroy();
      let o = this.viewer,
        r = null,
        a = null;
      (document.getElementById(this.cesiumID).style.cursor = "crosshair"),
        (o.scene.screenSpaceCameraController.enableRotate = !1),
        (o.scene.screenSpaceCameraController.enableZoom = !1),
        (this.gatherHandler = new e.ScreenSpaceEventHandler(o.scene.canvas)),
        this.gatherHandler.setInputAction((t) => {
          var i = o.camera.getPickRay(t.position),
            n = o.scene.globe.pick(i, o.scene);
          e.defined(n) &&
            ((a = o.entities.add({
              position: n,
              point: {
                color: e.Color.CHARTREUSE.withAlpha(1),
                pixelSize: 10,
                heightReference: e.HeightReference.CLAMP_TO_GROUND,
                outlineColor: e.Color.WHITE,
                outlineWidth: 1,
              },
            })),
            (r = o.entities.add({
              position: n,
              ellipse: {
                semiMinorAxis: 0.1,
                semiMajorAxis: 0.1,
                material: e.Color.GREENYELLOW.withAlpha(0.5),
                outline: !0,
                outlineColor: e.Color.WHITE,
                outlineWidth: 3,
              },
            })),
            this.gatherHandler.removeInputAction(
              e.ScreenSpaceEventType.LEFT_DOWN
            ));
        }, e.ScreenSpaceEventType.LEFT_DOWN),
        this.gatherHandler.setInputAction((t) => {
          if (null != a && null != r) {
            var i = o.camera.getPickRay(t.endPosition),
              n = o.scene.globe.pick(i, o.scene);
            if (n) {
              var l = a.position.getValue(e.JulianDate.now()),
                s = o.scene.globe.ellipsoid.cartesianToCartographic(l),
                c = o.scene.globe.ellipsoid.cartesianToCartographic(n),
                h = new e.EllipsoidGeodesic();
              h.setEndPoints(s, c);
              var d = h.surfaceDistance;
              d <= 0 ||
                ((r.ellipse.semiMinorAxis = new e.CallbackProperty(function (
                  e,
                  t
                ) {
                  return d;
                },
                !1)),
                (r.ellipse.semiMajorAxis = new e.CallbackProperty(function (
                  e,
                  t
                ) {
                  return d;
                },
                !1)));
            }
          }
        }, e.ScreenSpaceEventType.MOUSE_MOVE),
        this.gatherHandler.setInputAction((e) => {
          (document.getElementById(this.cesiumID).style.cursor = "default"),
            (o.scene.screenSpaceCameraController.enableRotate = !0),
            (o.scene.screenSpaceCameraController.enableZoom = !0),
            n.gatherHandlerDestroy(),
            o.entities.remove(a),
            (a = null),
            n.setAttributeForEntity(r, i, "circle"),
            t(r);
        }, e.ScreenSpaceEventType.RIGHT_CLICK);
    },
    rectangleGather(t, i) {
      let n = this;
      n.gatherHandlerDestroy();
      let o = null,
        r = null;
      (document.getElementById(this.cesiumID).style.cursor = "crosshair"),
        (this.viewer.scene.screenSpaceCameraController.enableRotate = !1),
        (this.viewer.scene.screenSpaceCameraController.enableZoom = !1),
        (this.gatherHandler = new e.ScreenSpaceEventHandler(
          this.viewer.scene.canvas
        )),
        this.gatherHandler.setInputAction((t) => {
          var a = n.viewer.camera.getPickRay(t.position),
            l = n.viewer.scene.globe.pick(a, n.viewer.scene);
          e.defined(l) &&
            ((r = n.viewer.entities.add({
              position: l,
              point: {
                color: e.Color.CHARTREUSE.withAlpha(1),
                pixelSize: 10,
                heightReference: e.HeightReference.CLAMP_TO_GROUND,
                outlineColor: e.Color.WHITE,
                outlineWidth: 1,
              },
            })),
            (o = n.viewer.entities.add({
              rectangle: {
                coordinates: e.Rectangle.fromCartesianArray([l, l]),
                material: e.Color.fromCssColorString(i.color).withAlpha(
                  i.alpha
                ),
              },
            })),
            this.gatherHandler.removeInputAction(
              e.ScreenSpaceEventType.LEFT_DOWN
            ));
        }, e.ScreenSpaceEventType.LEFT_DOWN),
        this.gatherHandler.setInputAction((t) => {
          if (null != r && null != o) {
            var i = n.viewer.camera.getPickRay(t.endPosition),
              a = n.viewer.scene.globe.pick(i, n.viewer.scene);
            if (a) {
              var l = r.position.getValue(e.JulianDate.now());
              o.rectangle.coordinates = new e.CallbackProperty(function (t, i) {
                return e.Rectangle.fromCartesianArray([l, a]);
              }, !1);
            }
          }
        }, e.ScreenSpaceEventType.MOUSE_MOVE),
        this.gatherHandler.setInputAction((e) => {
          (document.getElementById(this.cesiumID).style.cursor = "default"),
            (n.viewer.scene.screenSpaceCameraController.enableRotate = !0),
            (n.viewer.scene.screenSpaceCameraController.enableZoom = !0),
            n.viewer.entities.remove(r),
            n.gatherHandlerDestroy(),
            n.setAttributeForEntity(o, i, "rectangle"),
            t(o);
        }, e.ScreenSpaceEventType.RIGHT_CLICK);
    },
    billboardGather(t, i) {
      let n = this;
      this.gatherHandlerDestroy();
      let o = null;
      (document.getElementById(this.cesiumID).style.cursor = "crosshair"),
        (this.gatherHandler = new e.ScreenSpaceEventHandler(
          this.viewer.canvas
        )),
        this.gatherHandler.setInputAction(function (r) {
          var a = n.viewer.camera.getPickRay(r.position),
            l = n.viewer.scene.globe.pick(a, n.viewer.scene);
          if (!e.defined(l)) return;
          let s = n.cartesian3ToLngLat(l);
          (o = n.addBillboardEntity([s.lng, s.lat, s.height], i)),
            (document.getElementById(n.cesiumID).style.cursor = "default"),
            n.gatherHandlerDestroy(),
            t(o);
        }, e.ScreenSpaceEventType.LEFT_CLICK);
    },
    pointGather(t, i) {
      let n = this;
      n.gatherHandlerDestroy();
      let o = null;
      (document.getElementById(this.cesiumID).style.cursor = "crosshair"),
        (this.gatherHandler = new e.ScreenSpaceEventHandler(
          this.viewer.canvas
        )),
        this.gatherHandler.setInputAction(function (r) {
          var a = n.viewer.camera.getPickRay(r.position),
            l = n.viewer.scene.globe.pick(a, n.viewer.scene);
          if (!e.defined(l)) return;
          let s = n.cartesian3ToLngLat(l);
          (o = n.addPointEntity([s.lng, s.lat, s.height], i)),
            (document.getElementById(n.cesiumID).style.cursor = "default"),
            n.gatherHandlerDestroy(),
            n.setAttributeForEntity(o, i, "point"),
            t(o);
        }, e.ScreenSpaceEventType.LEFT_CLICK);
    },
    polylineGather(t, i) {
      let n = this;
      n.gatherHandlerDestroy();
      let o = null,
        r = [],
        a = [];
      (document.getElementById(this.cesiumID).style.cursor = "crosshair"),
        (this.gatherHandler = new e.ScreenSpaceEventHandler(
          this.viewer.canvas
        )),
        this.gatherHandler.setInputAction(function (t) {
          var l = n.viewer.camera.getPickRay(t.position),
            s = n.viewer.scene.globe.pick(l, n.viewer.scene);
          if (e.defined(s)) {
            var c = n.viewer.entities.add({
              position: s,
              point: {
                color: e.Color.WHITE,
                pixelSize: 5,
                heightReference: e.HeightReference.CLAMP_TO_GROUND,
                outlineColor: e.Color.BLACK,
                outlineWidth: 1,
              },
            });
            r.push(c),
              a.push(s),
              a.length >= 2 &&
                null == o &&
                (o = n.viewer.entities.add({
                  polyline: {
                    positions: new e.CallbackProperty(function (e, t) {
                      return a;
                    }, !1),
                    material: new e.Color.fromCssColorString(i.color).withAlpha(
                      i.alpha
                    ),
                    ...i,
                  },
                }));
          }
        }, e.ScreenSpaceEventType.LEFT_CLICK),
        this.gatherHandler.setInputAction(function (e) {
          for (var a = 0; a < r.length; a++) n.viewer.entities.remove(r[a]);
          (r = []),
            (document.getElementById(n.cesiumID).style.cursor = "default"),
            n.gatherHandlerDestroy(),
            n.setAttributeForEntity(o, i, "polyline"),
            t(o);
        }, e.ScreenSpaceEventType.RIGHT_CLICK);
    },
    polygonGather(t, i) {
      let n = this;
      n.gatherHandlerDestroy();
      let o = null,
        r = [],
        a = [];
      (document.getElementById(this.cesiumID).style.cursor = "crosshair"),
        (this.gatherHandler = new e.ScreenSpaceEventHandler(
          this.viewer.canvas
        )),
        this.gatherHandler.setInputAction(function (t) {
          var l = n.viewer.camera.getPickRay(t.position),
            s = n.viewer.scene.globe.pick(l, n.viewer.scene);
          if (e.defined(s)) {
            var c = n.viewer.entities.add({
              position: s,
              point: {
                color: e.Color.WHITE,
                pixelSize: 5,
                heightReference: e.HeightReference.CLAMP_TO_GROUND,
                outlineColor: e.Color.BLACK,
                outlineWidth: 1,
              },
            });
            r.push(c),
              a.push(s),
              a.length >= 3 &&
                (null == o
                  ? (o = n.viewer.entities.add({
                      polygon: {
                        hierarchy: new e.CallbackProperty(function (t, i) {
                          return new e.PolygonHierarchy(a, null);
                        }, !1),
                        material: e.Color.fromCssColorString(i.color).withAlpha(
                          i.alpha
                        ),
                        ...i,
                      },
                    }))
                  : (o.polygon.hierarchy = new e.CallbackProperty(function (
                      t,
                      i
                    ) {
                      return new e.PolygonHierarchy(a, null);
                    },
                    !1)));
          }
        }, e.ScreenSpaceEventType.LEFT_CLICK),
        this.gatherHandler.setInputAction(function (e) {
          for (var a = 0; a < r.length; a++) n.viewer.entities.remove(r[a]);
          (r = []),
            (document.getElementById(n.cesiumID).style.cursor = "default"),
            n.gatherHandlerDestroy(),
            n.setAttributeForEntity(o, i, "polygon"),
            t(o);
        }, e.ScreenSpaceEventType.RIGHT_CLICK);
    },
  },
  U = {
    rectangleEdit(t, i) {
      let n = this,
        o = this.viewer,
        r = null;
      (t.pointsId = []),
        (document.getElementById(this.cesiumID).style.cursor = "pointer");
      var a = t.rectangle.coordinates.getValue(),
        l = [],
        s = e.Cartesian3.fromRadians(a.west, a.north);
      (s.flag = "westNorth"), l.push(s);
      var c = e.Cartesian3.fromRadians(a.east, a.north);
      (c.flag = "eastNorth"), l.push(c);
      var h = e.Cartesian3.fromRadians(a.east, a.south);
      (h.flag = "eastSouth"), l.push(h);
      var d = e.Cartesian3.fromRadians(a.west, a.south);
      (d.flag = "westSouth"), l.push(d);
      for (var p = 0; p < l.length; p++) {
        var u = l[p],
          g = o.entities.add({
            name: "rectangleBorderEdit_point",
            position: u,
            point: {
              color: e.Color.WHITE,
              pixelSize: 8,
              outlineColor: e.Color.BLACK,
              outlineWidth: 1,
              heightReference: e.HeightReference.CLAMP_TO_GROUND,
            },
          });
        (g.flag = u.flag), t.pointsId.push(g.id);
      }
      var m = (a.west + a.east) / 2,
        v = (a.north + a.south) / 2,
        y = e.Cartesian3.fromRadians(m, v),
        f = o.entities.add({
          name: "rectangleCenterEdit_point",
          position: y,
          point: {
            color: e.Color.WHITE,
            pixelSize: 8,
            outlineColor: e.Color.BLACK,
            outlineWidth: 1,
            heightReference: e.HeightReference.CLAMP_TO_GROUND,
          },
        });
      (f.flag = "center"),
        t.pointsId.push(f.id),
        (t.handler = new e.ScreenSpaceEventHandler(o.scene.canvas)),
        t.handler.setInputAction((t) => {
          let i = t.position,
            n = o.scene.pick(i);
          if (e.defined(n)) {
            let e = n.id;
            ("rectangleBorderEdit_point" != e.name &&
              "rectangleCenterEdit_point" != e.name) ||
              (r = e);
          }
        }, e.ScreenSpaceEventType.LEFT_DOWN),
        t.handler.setInputAction((i) => {
          if (!r) return;
          (o.scene.screenSpaceCameraController.enableRotate = !1),
            (o.scene.screenSpaceCameraController.enableZoom = !1);
          var n = o.camera.getPickRay(i.endPosition),
            a = o.scene.globe.pick(n, o.scene);
          let l = [];
          if (a) {
            r.position = a;
            for (var s = 0; s < t.pointsId.length; s++)
              if (r.id == t.pointsId[s]) {
                ((c = r.position._value).flag = r.flag), l.push(c);
              } else {
                var c,
                  h = t.pointsId[s];
                ((c = o.entities.getById(h).position._value).flag =
                  o.entities.getById(h).flag),
                  l.push(c);
              }
            if (void 0 === r) return (D = e.Rectangle.fromDegrees(S, M, I, L));
            var d = o.scene.globe.ellipsoid,
              p = [],
              u = [];
            if ("westNorth" == r.flag || "eastSouth" == r.flag) {
              for (s = 0; s < l.length; s++)
                if ("westNorth" == l[s].flag || "eastSouth" == l[s].flag) {
                  var g = d.cartesianToCartographic(l[s]),
                    m = e.Math.toDegrees(g.longitude),
                    v = e.Math.toDegrees(g.latitude);
                  p.push(m), u.push(v);
                }
            } else if ("eastNorth" == r.flag || "westSouth" == r.flag) {
              for (s = 0; s < l.length; s++)
                if ("eastNorth" == l[s].flag || "westSouth" == l[s].flag) {
                  (g = d.cartesianToCartographic(l[s])),
                    (m = e.Math.toDegrees(g.longitude)),
                    (v = e.Math.toDegrees(g.latitude));
                  p.push(m), u.push(v);
                }
            } else if ("center" == r.flag) {
              g = d.cartesianToCartographic(r.position._value);
              var y = e.Math.toDegrees(g.longitude),
                f = e.Math.toDegrees(g.latitude),
                C = t.rectangle.coordinates.getValue(),
                P = e.Math.toDegrees(C.east) - e.Math.toDegrees(C.west),
                A = e.Math.toDegrees(C.north) - e.Math.toDegrees(C.south),
                w = y + P / 2;
              p.push(w);
              var F = y - P / 2;
              p.push(F);
              var E = f + A / 2;
              u.push(E);
              var T = f - A / 2;
              u.push(T);
            }
            var I = Math.max.apply(null, p),
              S = Math.min.apply(null, p),
              L = Math.max.apply(null, u),
              M = Math.min.apply(null, u);
            for (s = 0; s < t.pointsId.length; s++) {
              h = t.pointsId[s];
              var b = o.entities.getById(h);
              if (void 0 !== b && void 0 !== r && b.flag != r.flag)
                if ("westNorth" == b.flag)
                  b.position = e.Cartesian3.fromDegrees(S, L);
                else if ("eastNorth" == b.flag)
                  b.position = e.Cartesian3.fromDegrees(I, L);
                else if ("eastSouth" == b.flag)
                  b.position = e.Cartesian3.fromDegrees(I, M);
                else if ("westSouth" == b.flag)
                  b.position = e.Cartesian3.fromDegrees(S, M);
                else if ("center" == b.flag) {
                  (y = (S + I) / 2), (f = (L + M) / 2);
                  b.position = e.Cartesian3.fromDegrees(y, f);
                }
              if (S >= I || M >= L) return void (r = void 0);
              var D = e.Rectangle.fromDegrees(S, M, I, L);
              t.rectangle.coordinates = new e.CallbackProperty(function (e, t) {
                return D;
              }, !1);
            }
          }
        }, e.ScreenSpaceEventType.MOUSE_MOVE),
        t.handler.setInputAction((e) => {
          (r = null),
            (o.scene.screenSpaceCameraController.enableRotate = !0),
            (o.scene.screenSpaceCameraController.enableZoom = !0);
        }, e.ScreenSpaceEventType.LEFT_UP),
        t.handler.setInputAction((e) => {
          n.closeRectangleEdit(t), i(t);
        }, e.ScreenSpaceEventType.RIGHT_CLICK);
    },
    closeRectangleEdit(t) {
      (document.getElementById(this.cesiumID).style.cursor = "default"),
        t.handler.removeInputAction(e.ScreenSpaceEventType.LEFT_DOWN),
        t.handler.removeInputAction(e.ScreenSpaceEventType.MOUSE_MOVE),
        t.handler.removeInputAction(e.ScreenSpaceEventType.RIGHT_CLICK),
        t.handler.removeInputAction(e.ScreenSpaceEventType.LEFT_UP);
      var i = t.rectangle.coordinates.getValue(),
        n = e.Math.toDegrees(i.east),
        o = e.Math.toDegrees(i.west),
        r = e.Math.toDegrees(i.north),
        a = e.Math.toDegrees(i.south);
      return (
        (t.FFCoordinates.east = n),
        (t.FFCoordinates.west = o),
        (t.FFCoordinates.north = r),
        (t.FFCoordinates.south = a),
        (t.FFPosition = e.Rectangle.fromDegrees(o, a, n, r)),
        this.removeFFEntityIDArr(t.pointsId),
        (t.pointsId = []),
        t
      );
    },
    circleEdit(t, i) {
      let n = this,
        o = this.viewer,
        r = null;
      t.pointsId = [];
      let a = 101194;
      document.getElementById(this.cesiumID).style.cursor = "pointer";
      let l = o.entities.add({
        name: "circleCenterEdit_point",
        position: t.FFPosition,
        point: {
          color: e.Color.WHITE,
          pixelSize: 8,
          outlineColor: e.Color.BLACK,
          outlineWidth: 1,
          heightReference: e.HeightReference.CLAMP_TO_GROUND,
        },
      });
      t.pointsId.push(l.id);
      var s = t.FFRadius / a,
        c = e.Cartesian3.fromDegrees(
          t.FFCenterPoint[0] + s,
          t.FFCenterPoint[1],
          t.FFCenterPoint[2]
        ),
        h = o.entities.add({
          name: "circleBorderEdit_point",
          position: c,
          point: {
            color: e.Color.WHITE,
            pixelSize: 8,
            outlineColor: e.Color.BLACK,
            outlineWidth: 1,
            heightReference: e.HeightReference.CLAMP_TO_GROUND,
          },
        });
      t.pointsId.push(h.id),
        (t.handler = new e.ScreenSpaceEventHandler(o.scene.canvas)),
        t.handler.setInputAction((t) => {
          let i = t.position,
            n = o.scene.pick(i);
          e.defined(n) &&
            (("circleCenterEdit_point" != n.id.name &&
              "circleBorderEdit_point" != n.id.name) ||
              (r = n.id));
        }, e.ScreenSpaceEventType.LEFT_DOWN),
        t.handler.setInputAction((i) => {
          var n = o.camera.getPickRay(i.endPosition),
            l = o.scene.globe.pick(n, o.scene);
          if (l && null != r) {
            if (((r.position = l), "circleBorderEdit_point" == r.name)) {
              (o.scene.screenSpaceCameraController.enableRotate = !1),
                (o.scene.screenSpaceCameraController.enableZoom = !1);
              var s = o.scene.globe.ellipsoid.cartesianToCartographic(
                  t.position.getValue(e.JulianDate.now())
                ),
                c = o.scene.globe.ellipsoid.cartesianToCartographic(
                  r.position.getValue(e.JulianDate.now())
                ),
                h = new e.EllipsoidGeodesic();
              h.setEndPoints(s, c);
              var d = h.surfaceDistance;
              (t.ellipse.semiMinorAxis = new e.CallbackProperty(function (
                e,
                t
              ) {
                return d;
              },
              !1)),
                (t.ellipse.semiMajorAxis = new e.CallbackProperty(function (
                  e,
                  t
                ) {
                  return d;
                },
                !1));
            }
            if ("circleCenterEdit_point" == r.name) {
              (o.scene.screenSpaceCameraController.enableRotate = !1),
                (o.scene.screenSpaceCameraController.enableZoom = !1);
              for (
                var p = t.ellipse.semiMinorAxis.getValue() / a,
                  u = o.scene.globe.ellipsoid.cartesianToCartographic(
                    r.position.getValue(e.JulianDate.now())
                  ),
                  g = e.Math.toDegrees(u.longitude),
                  m = e.Math.toDegrees(u.latitude),
                  v = e.Cartesian3.fromDegrees(g + p, m, t.FFCenterPoint[2]),
                  y = 0;
                y < t.pointsId.length;
                y++
              ) {
                var f = o.entities.getById(t.pointsId[y]);
                "circleBorderEdit_point" == f.name && (f.position = v);
              }
              var C = r.position.getValue(e.JulianDate.now());
              t.position = new e.CallbackProperty(function (e, t) {
                return C;
              }, !1);
            }
          }
        }, e.ScreenSpaceEventType.MOUSE_MOVE),
        t.handler.setInputAction((e) => {
          (r = null),
            (o.scene.screenSpaceCameraController.enableRotate = !0),
            (o.scene.screenSpaceCameraController.enableZoom = !0);
        }, e.ScreenSpaceEventType.LEFT_UP),
        t.handler.setInputAction((e) => {
          n.closeCircleEdit(t), i(t);
        }, e.ScreenSpaceEventType.RIGHT_CLICK);
    },
    closeCircleEdit(t) {
      let i = this;
      return (
        (document.getElementById(i.cesiumID).style.cursor = "default"),
        t.handler.removeInputAction(e.ScreenSpaceEventType.LEFT_DOWN),
        t.handler.removeInputAction(e.ScreenSpaceEventType.MOUSE_MOVE),
        t.handler.removeInputAction(e.ScreenSpaceEventType.RIGHT_CLICK),
        t.handler.removeInputAction(e.ScreenSpaceEventType.LEFT_UP),
        i.setAttributeForEntity(t, t.FFOption, "circle"),
        i.removeFFEntityIDArr(t.pointsId),
        (t.pointsId = []),
        t
      );
    },
    polygonEdit(t, i) {
      let n = this,
        o = this.viewer;
      (t.pointsId = []), (t.halfPointsId = []);
      let r = null;
      t.id ||
        (t.id = "polygonEdit_" + new Date().getTime() + "_" + Math.random()),
        (document.getElementById(this.cesiumID).style.cursor = "pointer");
      for (var a = 0; a < t.FFPosition.length; a++) {
        var l = t.FFPosition[a],
          s = o.entities.add({
            name: "polygonEdit_point",
            position: l,
            point: {
              color: e.Color.WHITE,
              pixelSize: 8,
              outlineColor: e.Color.BLACK,
              outlineWidth: 1,
              heightReference: e.HeightReference.CLAMP_TO_GROUND,
            },
          });
        t.pointsId.push(s.id);
      }
      for (a = 0; a < t.FFPosition.length; a++) {
        let i = null;
        if (a == t.FFPosition.length - 1) {
          var c = (t.FFPosition[a].x + t.FFPosition[0].x) / 2,
            h = (t.FFPosition[a].y + t.FFPosition[0].y) / 2,
            d = (t.FFPosition[a].z + t.FFPosition[0].z) / 2;
          i = new e.Cartesian3(c, h, d);
        } else {
          (c = (t.FFPosition[a].x + t.FFPosition[a + 1].x) / 2),
            (h = (t.FFPosition[a].y + t.FFPosition[a + 1].y) / 2),
            (d = (t.FFPosition[a].z + t.FFPosition[a + 1].z) / 2);
          i = new e.Cartesian3(c, h, d);
        }
        var p = {
          name: "polygonEdit_half_point",
          position: i,
          point: {
            color: e.Color.RED,
            pixelSize: 8,
            outlineColor: e.Color.BLACK,
            outlineWidth: 1,
            heightReference: e.HeightReference.CLAMP_TO_GROUND,
          },
        };
        a == t.pointsId.length - 1
          ? (p.positionFlag = [a, 0])
          : (p.positionFlag = [a, a + 1]);
        s = o.entities.add(p);
        t.halfPointsId.push(s.id);
      }
      (t.handler = new e.ScreenSpaceEventHandler(o.scene.canvas)),
        t.handler.setInputAction((i) => {
          let n = i.position,
            a = o.scene.pick(n);
          if (e.defined(a)) {
            let i = a.id;
            if ("polygonEdit_point" === i.name) r = i;
            else if ("polygonEdit_half_point" === i.name) {
              let a = o.scene.globe.ellipsoid,
                m = o.camera.pickEllipsoid(n, a);
              if (!m) return;
              var l = o.entities.add({
                name: "polygonEdit_point",
                position: m,
                point: {
                  color: e.Color.WHITE,
                  pixelSize: 8,
                  outlineColor: e.Color.BLACK,
                  outlineWidth: 1,
                  heightReference: e.HeightReference.CLAMP_TO_GROUND,
                },
              });
              (r = l), t.pointsId.splice(i.positionFlag[0] + 1, 0, l.id);
              for (var s = 0; s < t.halfPointsId.length; s++)
                o.entities.remove(o.entities.getById(t.halfPointsId[s]));
              t.halfPointsId = [];
              for (s = 0; s < t.pointsId.length; s++) {
                var c = null,
                  h = null;
                s == t.pointsId.length - 1
                  ? ((c = o.entities.getById(t.pointsId[s]).position._value),
                    (h = o.entities.getById(t.pointsId[0]).position._value))
                  : ((c = o.entities.getById(t.pointsId[s]).position._value),
                    (h = o.entities.getById(t.pointsId[s + 1]).position
                      ._value));
                var d = (c.x + h.x) / 2,
                  p = (c.y + h.y) / 2,
                  u = (c.z + h.z) / 2,
                  g = {
                    name: "polygonEdit_half_point",
                    position: new e.Cartesian3(d, p, u),
                    point: {
                      color: e.Color.RED,
                      pixelSize: 8,
                      outlineColor: e.Color.BLACK,
                      outlineWidth: 1,
                      heightReference: e.HeightReference.CLAMP_TO_GROUND,
                    },
                  };
                s == t.pointsId.length - 1
                  ? (g.positionFlag = [s, 0])
                  : (g.positionFlag = [s, s + 1]);
                l = o.entities.add(g);
                t.halfPointsId.push(l.id);
              }
            }
          }
        }, e.ScreenSpaceEventType.LEFT_DOWN),
        t.handler.setInputAction((i) => {
          if (r && "polygonEdit_point" == r.name) {
            (o.scene.screenSpaceCameraController.enableRotate = !1),
              (o.scene.screenSpaceCameraController.enableZoom = !1);
            var n = o.camera.getPickRay(i.endPosition),
              a = o.scene.globe.pick(n, o.scene);
            let m = [];
            if (!a) return;
            r.position = a;
            for (var l = 0; l < t.pointsId.length; l++)
              if (r.id == t.pointsId[l]) m.push(r.position._value);
              else {
                var s = t.pointsId[l];
                m.push(o.entities.getById(s).position._value);
              }
            for (l = 0; l < t.halfPointsId.length; l++) {
              var c = o.entities.getById(t.halfPointsId[l]);
              if (void 0 !== c) {
                var h = c.positionFlag[0],
                  d = c.positionFlag[1];
                if (void 0 !== m[h] && void 0 !== m[d]) {
                  var p = (m[h].x + m[d].x) / 2,
                    u = (m[h].y + m[d].y) / 2,
                    g = (m[h].z + m[d].z) / 2;
                  a = new e.Cartesian3(p, u, g);
                  c.position = a;
                }
              }
            }
            t.polygon.hierarchy = new e.CallbackProperty(function (t, i) {
              return new e.PolygonHierarchy(m, null);
            }, !1);
          }
        }, e.ScreenSpaceEventType.MOUSE_MOVE),
        t.handler.setInputAction((e) => {
          (r = null),
            (o.scene.screenSpaceCameraController.enableRotate = !0),
            (o.scene.screenSpaceCameraController.enableZoom = !0);
        }, e.ScreenSpaceEventType.LEFT_UP),
        t.handler.setInputAction((e) => {
          n.closePolygonEdit(t), i(t);
        }, e.ScreenSpaceEventType.RIGHT_CLICK);
    },
    closePolygonEdit(t) {
      let i = this;
      (document.getElementById(i.cesiumID).style.cursor = "default"),
        t.handler.removeInputAction(e.ScreenSpaceEventType.LEFT_DOWN),
        t.handler.removeInputAction(e.ScreenSpaceEventType.MOUSE_MOVE),
        t.handler.removeInputAction(e.ScreenSpaceEventType.RIGHT_CLICK),
        t.handler.removeInputAction(e.ScreenSpaceEventType.LEFT_UP);
      let n = i.cartesian3ArrToLngLatHeightArr(
        t.polygon.hierarchy.getValue().positions
      );
      return (
        (t.FFCoordinates = n),
        (t.FFPosition = t.polygon.hierarchy.getValue().positions),
        i.removeFFEntityIDArr(t.pointsId),
        (t.pointsId = []),
        i.removeFFEntityIDArr(t.halfPointsId),
        (t.halfPointsId = []),
        t
      );
    },
    polylineEdit(t, i) {
      let n = this,
        o = this.viewer;
      (t.pointsId = []), (t.halfPointsId = []);
      let r = null;
      t.id ||
        (t.id = "polylineEdit_" + new Date().getTime() + "_" + Math.random()),
        (document.getElementById(this.cesiumID).style.cursor = "pointer");
      for (var a = 0; a < t.FFPosition.length; a++) {
        var l = t.FFPosition[a],
          s = o.entities.add({
            name: "polylineEdit_point",
            position: l,
            point: {
              color: e.Color.WHITE,
              pixelSize: 8,
              outlineColor: e.Color.BLACK,
              outlineWidth: 1,
              heightReference: e.HeightReference.CLAMP_TO_GROUND,
            },
          });
        t.pointsId.push(s.id);
      }
      for (a = 0; a < t.FFPosition.length - 1; a++) {
        var c = (t.FFPosition[a].x + t.FFPosition[a + 1].x) / 2,
          h = (t.FFPosition[a].y + t.FFPosition[a + 1].y) / 2,
          d = (t.FFPosition[a].z + t.FFPosition[a + 1].z) / 2,
          p = {
            name: "polylineEdit_half_point",
            position: (l = new e.Cartesian3(c, h, d)),
            point: {
              color: e.Color.RED,
              pixelSize: 8,
              outlineColor: e.Color.BLACK,
              outlineWidth: 1,
              heightReference: e.HeightReference.CLAMP_TO_GROUND,
            },
          };
        p.positionFlag = [a, a + 1];
        s = o.entities.add(p);
        t.halfPointsId.push(s.id);
      }
      (t.handler = new e.ScreenSpaceEventHandler(o.scene.canvas)),
        t.handler.setInputAction((i) => {
          let n = i.position,
            a = o.scene.pick(n);
          if (e.defined(a)) {
            let i = a.id;
            if (
              ("polylineEdit_point" === i.name && (r = i),
              "polylineEdit_half_point" === i.name)
            ) {
              let a = o.scene.globe.ellipsoid,
                v = o.camera.pickEllipsoid(n, a);
              if (!v) return;
              var l = {
                  name: "polylineEdit_point",
                  position: v,
                  point: {
                    color: e.Color.WHITE,
                    pixelSize: 8,
                    outlineColor: e.Color.BLACK,
                    outlineWidth: 1,
                    heightReference: e.HeightReference.CLAMP_TO_GROUND,
                  },
                },
                s = o.entities.add(l);
              (r = s), t.pointsId.splice(i.positionFlag[0] + 1, 0, s.id);
              for (var c = 0; c < t.halfPointsId.length; c++)
                o.entities.remove(o.entities.getById(t.halfPointsId[c]));
              t.halfPointsId = [];
              for (c = 0; c < t.pointsId.length - 1; c++) {
                var h = o.entities.getById(t.pointsId[c]).position._value,
                  d = o.entities.getById(t.pointsId[c + 1]).position._value,
                  p = (h.x + d.x) / 2,
                  u = (h.y + d.y) / 2,
                  g = (h.z + d.z) / 2,
                  m = {
                    name: "polylineEdit_half_point",
                    position: new e.Cartesian3(p, u, g),
                    point: {
                      color: e.Color.RED,
                      pixelSize: 8,
                      outlineColor: e.Color.BLACK,
                      outlineWidth: 1,
                      heightReference: e.HeightReference.CLAMP_TO_GROUND,
                    },
                  };
                m.positionFlag = [c, c + 1];
                s = o.entities.add(m);
                t.halfPointsId.push(s.id);
              }
            }
          }
        }, e.ScreenSpaceEventType.LEFT_DOWN),
        t.handler.setInputAction((i) => {
          if (r && "polylineEdit_point" == r.name) {
            (o.scene.screenSpaceCameraController.enableRotate = !1),
              (o.scene.screenSpaceCameraController.enableZoom = !1);
            var n = o.camera.getPickRay(i.endPosition),
              a = o.scene.globe.pick(n, o.scene);
            let c = [];
            if (!a) return;
            r.position = a;
            for (var l = 0; l < t.pointsId.length; l++)
              if (r.id == t.pointsId[l]) c.push(r.position._value);
              else {
                var s = t.pointsId[l];
                c.push(o.entities.getById(s).position._value);
              }
            t.polyline.positions = new e.CallbackProperty(function (i, n) {
              for (var r = 0; r < t.halfPointsId.length; r++) {
                var a = o.entities.getById(t.halfPointsId[r]);
                if (void 0 !== a) {
                  var l = a.positionFlag[0],
                    s = a.positionFlag[1];
                  if (void 0 !== c[l] && void 0 !== c[s]) {
                    var h = (c[l].x + c[s].x) / 2,
                      d = (c[l].y + c[s].y) / 2,
                      p = (c[l].z + c[s].z) / 2,
                      u = new e.Cartesian3(h, d, p);
                    a.position = u;
                  }
                }
              }
              return c;
            }, !1);
          }
        }, e.ScreenSpaceEventType.MOUSE_MOVE),
        t.handler.setInputAction((e) => {
          (r = null),
            (o.scene.screenSpaceCameraController.enableRotate = !0),
            (o.scene.screenSpaceCameraController.enableZoom = !0);
        }, e.ScreenSpaceEventType.LEFT_UP),
        t.handler.setInputAction((e) => {
          n.closePolylineEdit(t), i(t);
        }, e.ScreenSpaceEventType.RIGHT_CLICK);
    },
    closePolylineEdit(t) {
      let i = this;
      return (
        (document.getElementById(i.cesiumID).style.cursor = "default"),
        t.handler.removeInputAction(e.ScreenSpaceEventType.LEFT_DOWN),
        t.handler.removeInputAction(e.ScreenSpaceEventType.MOUSE_MOVE),
        t.handler.removeInputAction(e.ScreenSpaceEventType.RIGHT_CLICK),
        t.handler.removeInputAction(e.ScreenSpaceEventType.LEFT_UP),
        i.setAttributeForEntity(t, t.FFOption, "polyline"),
        i.removeFFEntityIDArr(t.pointsId),
        (t.pointsId = []),
        i.removeFFEntityIDArr(t.halfPointsId),
        (t.halfPointsId = []),
        t
      );
    },
    pointEdit(t, i) {
      let n = this,
        o = this.viewer;
      (t.timer = null),
        (t.isEditting = !1),
        (t.point.outlineWidth = 4),
        (t.point.outlineColor = new e.Color.fromCssColorString(
          "#0000FF"
        ).withAlpha(1)),
        t.id ||
          (t.id = "pointEdit_" + new Date().getTime() + "_" + Math.random()),
        (document.getElementById(this.cesiumID).style.cursor = "pointer"),
        (t.handler = new e.ScreenSpaceEventHandler(o.scene.canvas)),
        t.handler.setInputAction((i) => {
          let n = o.scene.pick(i.position);
          e.defined(n) &&
            (n.id.id != t.id || t.isEditting || (t.isEditting = !0));
        }, e.ScreenSpaceEventType.LEFT_DOWN),
        t.handler.setInputAction((e) => {
          if (t.isEditting) {
            (o.scene.screenSpaceCameraController.enableRotate = !1),
              (o.scene.screenSpaceCameraController.enableZoom = !1);
            var i = o.camera.getPickRay(e.endPosition),
              n = o.scene.globe.pick(i, o.scene);
            if (!n) return;
            t.position = n;
          }
        }, e.ScreenSpaceEventType.MOUSE_MOVE),
        t.handler.setInputAction((e) => {
          (o.scene.screenSpaceCameraController.enableRotate = !0),
            (o.scene.screenSpaceCameraController.enableZoom = !0),
            (t.isEditting = !1);
        }, e.ScreenSpaceEventType.LEFT_UP),
        t.handler.setInputAction((e) => {
          n.closePointEdit(t), i(t);
        }, e.ScreenSpaceEventType.RIGHT_CLICK);
    },
    closePointEdit(t) {
      (document.getElementById(this.cesiumID).style.cursor = "default"),
        t.handler.removeInputAction(e.ScreenSpaceEventType.LEFT_DOWN),
        t.handler.removeInputAction(e.ScreenSpaceEventType.MOUSE_MOVE),
        t.handler.removeInputAction(e.ScreenSpaceEventType.RIGHT_CLICK),
        t.handler.removeInputAction(e.ScreenSpaceEventType.LEFT_UP),
        (t.isEditting = !1),
        (t.point.outlineWidth = 0),
        this.setAttributeForEntity(t, t.FFOption, "point");
    },
    billboardEdit(t, i) {
      let n = this,
        o = this.viewer;
      (t.timer = null),
        (t.isEditting = !1),
        (t.billboard.color = new e.Color.fromCssColorString(
          "#FFFFFF"
        ).withAlpha(0.6)),
        t.id ||
          (t.id =
            "billboardEdit_" + new Date().getTime() + "_" + Math.random()),
        (document.getElementById(this.cesiumID).style.cursor = "pointer"),
        (t.handler = new e.ScreenSpaceEventHandler(o.scene.canvas)),
        t.handler.setInputAction((i) => {
          let n = o.scene.pick(i.position);
          e.defined(n) &&
            (n.id.id != t.id || t.isEditting || (t.isEditting = !0));
        }, e.ScreenSpaceEventType.LEFT_DOWN),
        t.handler.setInputAction((e) => {
          if (t.isEditting) {
            (o.scene.screenSpaceCameraController.enableRotate = !1),
              (o.scene.screenSpaceCameraController.enableZoom = !1);
            var i = o.camera.getPickRay(e.endPosition),
              n = o.scene.globe.pick(i, o.scene);
            if (!n) return;
            t.position = n;
          }
        }, e.ScreenSpaceEventType.MOUSE_MOVE),
        t.handler.setInputAction((e) => {
          (o.scene.screenSpaceCameraController.enableRotate = !0),
            (o.scene.screenSpaceCameraController.enableZoom = !0),
            (t.isEditting = !1);
        }, e.ScreenSpaceEventType.LEFT_UP),
        t.handler.setInputAction((e) => {
          n.closeBillboardEdit(t), i(t);
        }, e.ScreenSpaceEventType.RIGHT_CLICK);
    },
    closeBillboardEdit(t) {
      (document.getElementById(this.cesiumID).style.cursor = "default"),
        t.handler.removeInputAction(e.ScreenSpaceEventType.LEFT_DOWN),
        t.handler.removeInputAction(e.ScreenSpaceEventType.MOUSE_MOVE),
        t.handler.removeInputAction(e.ScreenSpaceEventType.RIGHT_CLICK),
        t.handler.removeInputAction(e.ScreenSpaceEventType.LEFT_UP),
        (t.isEditting = !1),
        (t.billboard.color = new e.Color.fromCssColorString(
          "#FFFFFF"
        ).withAlpha(1)),
        this.setAttributeForEntity(t, t.FFOption, "billboard");
    },
  };
function x(t, i) {
  return i.entities.add({
    position: t,
    billboard: {
      image:
        "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAY1BMVEX///+4t624t63BRkbbj4//9/fbjIz/6+v/5+f/5ub/3d3/1dX/0ND/z8/bgYH/xsb/vb3/urr/tLT/qqr/qKj/kpL/cHD/XFz/WFjbaWn/dnb/YGD/WVn/ior/bm7bb2////8vWcu1AAAAA3RSTlMAAIAXzkf+AAAAAWJLR0QAiAUdSAAAAAd0SU1FB9sFEhYZAAV2IPIAAACASURBVBjTjc7JEoMgEEVR0895wmiYRf//L4WiSVV2uRuKs+lXVX/0iiGWXgagbpo6UQa0XT8MfdeiwDjNyzJPIwNWsb1jm1iRQezHJ3bsgkEqbWJaSQbr/GnM6Z3NQAiX19pfAcRX7uCUcuEuZwmwUlqAylKiNJ3oOz1R+jL89gAYeAaPM7P+sgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxOC0wNi0yOFQyMjozNDowMyswODowMByu+LsAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTEtMDUtMThUMjI6MjU6MDArMDg6MDAs8HGJAAAAQ3RFWHRzb2Z0d2FyZQAvdXNyL2xvY2FsL2ltYWdlbWFnaWNrL3NoYXJlL2RvYy9JbWFnZU1hZ2ljay03Ly9pbmRleC5odG1svbV5CgAAABh0RVh0VGh1bWI6OkRvY3VtZW50OjpQYWdlcwAxp/+7LwAAABd0RVh0VGh1bWI6OkltYWdlOjpIZWlnaHQAMTYdr15vAAAAFnRFWHRUaHVtYjo6SW1hZ2U6OldpZHRoADE25QCe4gAAABl0RVh0VGh1bWI6Ok1pbWV0eXBlAGltYWdlL3BuZz+yVk4AAAAXdEVYdFRodW1iOjpNVGltZQAxMzA1NzI4NzAwvZ5IOQAAABB0RVh0VGh1bWI6OlNpemUANDM2QnL66p4AAABedEVYdFRodW1iOjpVUkkAZmlsZTovLy9ob21lL3d3d3Jvb3QvbmV3c2l0ZS93d3cuZWFzeWljb24ubmV0L2Nkbi1pbWcuZWFzeWljb24uY24vc3JjLzM0Ny8zNDc1MS5wbmfjEwQRAAAAAElFTkSuQmCC",
      width: 12,
      height: 12,
      heightReference: e.HeightReference.CLAMP_TO_GROUND,
    },
  });
}
let O = { version: "1.0.0", PlotUtils: {} };
(O.PlotUtils.distance = function (e, t) {
  return Math.sqrt(Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2));
}),
  (O.PlotUtils.wholeDistance = function (e) {
    for (var t = 0, i = 0; i < e.length - 1; i++)
      t += O.PlotUtils.distance(e[i], e[i + 1]);
    return t;
  }),
  (O.PlotUtils.getBaseLength = function (e) {
    return Math.pow(O.PlotUtils.wholeDistance(e), 0.99);
  }),
  (O.PlotUtils.mid = function (e, t) {
    return [(e[0] + t[0]) / 2, (e[1] + t[1]) / 2];
  }),
  (O.PlotUtils.getCircleCenterOfThreePoints = function (e, t, i) {
    var n = [(e[0] + t[0]) / 2, (e[1] + t[1]) / 2],
      o = [n[0] - e[1] + t[1], n[1] + e[0] - t[0]],
      r = [(e[0] + i[0]) / 2, (e[1] + i[1]) / 2],
      a = [r[0] - e[1] + i[1], r[1] + e[0] - i[0]];
    return O.PlotUtils.getIntersectPoint(n, o, r, a);
  }),
  (O.PlotUtils.getIntersectPoint = function (e, t, i, n) {
    if (e[1] == t[1]) {
      var o = (n[0] - i[0]) / (n[1] - i[1]),
        r = o * (e[1] - i[1]) + i[0],
        a = e[1];
      return [r, a];
    }
    if (i[1] == n[1]) {
      var l = (t[0] - e[0]) / (t[1] - e[1]);
      return [(r = l * (i[1] - e[1]) + e[0]), (a = i[1])];
    }
    return (
      (l = (t[0] - e[0]) / (t[1] - e[1])),
      (o = (n[0] - i[0]) / (n[1] - i[1])),
      [
        (r =
          l * (a = (l * e[1] - e[0] - o * i[1] + i[0]) / (l - o)) -
          l * e[1] +
          e[0]),
        a,
      ]
    );
  }),
  (O.PlotUtils.getAzimuth = function (e, t) {
    var i,
      n = Math.asin(Math.abs(t[1] - e[1]) / O.PlotUtils.distance(e, t));
    return (
      t[1] >= e[1] && t[0] >= e[0]
        ? (i = n + Math.PI)
        : t[1] >= e[1] && t[0] < e[0]
        ? (i = O.Constants.TWO_PI - n)
        : t[1] < e[1] && t[0] < e[0]
        ? (i = n)
        : t[1] < e[1] && t[0] >= e[0] && (i = Math.PI - n),
      i
    );
  }),
  (O.PlotUtils.getAngleOfThreePoints = function (e, t, i) {
    var n = O.PlotUtils.getAzimuth(t, e) - O.PlotUtils.getAzimuth(t, i);
    return 0 > n ? n + O.Constants.TWO_PI : n;
  }),
  (O.PlotUtils.isClockWise = function (e, t, i) {
    return (i[1] - e[1]) * (t[0] - e[0]) > (t[1] - e[1]) * (i[0] - e[0]);
  }),
  (O.PlotUtils.getPointOnLine = function (e, t, i) {
    return [t[0] + e * (i[0] - t[0]), t[1] + e * (i[1] - t[1])];
  }),
  (O.PlotUtils.getCubicValue = function (e, t, i, n, o) {
    var r = 1 - (e = Math.max(Math.min(e, 1), 0)),
      a = e * e,
      l = a * e,
      s = r * r,
      c = s * r;
    return [
      c * t[0] + 3 * s * e * i[0] + 3 * r * a * n[0] + l * o[0],
      c * t[1] + 3 * s * e * i[1] + 3 * r * a * n[1] + l * o[1],
    ];
  }),
  (O.PlotUtils.getThirdPoint = function (e, t, i, n, o) {
    var r = O.PlotUtils.getAzimuth(e, t),
      a = o ? r + i : r - i,
      l = n * Math.cos(a),
      s = n * Math.sin(a);
    return [t[0] + l, t[1] + s];
  }),
  (O.PlotUtils.getArcPoints = function (e, t, i, n) {
    var o,
      r,
      a = [],
      l = n - i;
    l = 0 > l ? l + O.Constants.TWO_PI : l;
    for (var s = 0; s <= O.Constants.FITTING_COUNT; s++) {
      var c = i + (l * s) / O.Constants.FITTING_COUNT;
      (o = e[0] + t * Math.cos(c)),
        (r = e[1] + t * Math.sin(c)),
        a.push([o, r]);
    }
    return a;
  }),
  (O.PlotUtils.getBisectorNormals = function (e, t, i, n) {
    var o = O.PlotUtils.getNormal(t, i, n),
      r = Math.sqrt(o[0] * o[0] + o[1] * o[1]),
      a = o[0] / r,
      l = o[1] / r,
      s = O.PlotUtils.distance(t, i),
      c = O.PlotUtils.distance(i, n);
    if (r > O.Constants.ZERO_TOLERANCE)
      if (O.PlotUtils.isClockWise(t, i, n)) {
        var h = e * s,
          d = i[0] - h * l,
          p = i[1] + h * a,
          u = [d, p];
        h = e * c;
        var g = [(d = i[0] + h * l), (p = i[1] - h * a)];
      } else
        (h = e * s),
          (u = [(d = i[0] + h * l), (p = i[1] - h * a)]),
          (h = e * c),
          (g = [(d = i[0] - h * l), (p = i[1] + h * a)]);
    else
      (u = [(d = i[0] + e * (t[0] - i[0])), (p = i[1] + e * (t[1] - i[1]))]),
        (g = [(d = i[0] + e * (n[0] - i[0])), (p = i[1] + e * (n[1] - i[1]))]);
    return [u, g];
  }),
  (O.PlotUtils.getNormal = function (e, t, i) {
    var n = e[0] - t[0],
      o = e[1] - t[1],
      r = Math.sqrt(n * n + o * o);
    (n /= r), (o /= r);
    var a = i[0] - t[0],
      l = i[1] - t[1],
      s = Math.sqrt(a * a + l * l);
    return [n + (a /= s), o + (l /= s)];
  }),
  (O.PlotUtils.getCurvePoints = function (e, t) {
    for (
      var i = [O.PlotUtils.getLeftMostControlPoint(t)], n = 0;
      n < t.length - 2;
      n++
    ) {
      var o = t[n],
        r = t[n + 1],
        a = t[n + 2],
        l = O.PlotUtils.getBisectorNormals(e, o, r, a);
      i = i.concat(l);
    }
    var s = O.PlotUtils.getRightMostControlPoint(t);
    i.push(s);
    var c = [];
    for (n = 0; n < t.length - 1; n++) {
      (o = t[n]), (r = t[n + 1]), c.push(o);
      for (e = 0; e < O.Constants.FITTING_COUNT; e++) {
        var h = O.PlotUtils.getCubicValue(
          e / O.Constants.FITTING_COUNT,
          o,
          i[2 * n],
          i[2 * n + 1],
          r
        );
        c.push(h);
      }
      c.push(r);
    }
    return c;
  }),
  (O.PlotUtils.getLeftMostControlPoint = function (e) {
    var i = e[0],
      n = e[1],
      o = e[2],
      r = O.PlotUtils.getBisectorNormals(0, i, n, o)[0],
      a = O.PlotUtils.getNormal(i, n, o);
    if (Math.sqrt(a[0] * a[0] + a[1] * a[1]) > O.Constants.ZERO_TOLERANCE)
      var l = O.PlotUtils.mid(i, n),
        s = i[0] - l[0],
        c = i[1] - l[1],
        h = 2 / O.PlotUtils.distance(i, n),
        d = -h * c,
        p = h * s,
        u = d * d - p * p,
        g = 2 * d * p,
        m = p * p - d * d,
        v = r[0] - l[0],
        y = r[1] - l[1],
        f = l[0] + u * v + g * y,
        C = l[1] + g * v + m * y;
    else (f = i[0] + t * (n[0] - i[0])), (C = i[1] + t * (n[1] - i[1]));
    return [f, C];
  }),
  (O.PlotUtils.getRightMostControlPoint = function (e) {
    var i = e.length,
      n = e[i - 3],
      o = e[i - 2],
      r = e[i - 1],
      a = O.PlotUtils.getBisectorNormals(0, n, o, r)[1],
      l = O.PlotUtils.getNormal(n, o, r);
    if (Math.sqrt(l[0] * l[0] + l[1] * l[1]) > O.Constants.ZERO_TOLERANCE)
      var s = O.PlotUtils.mid(o, r),
        c = r[0] - s[0],
        h = r[1] - s[1],
        d = 2 / O.PlotUtils.distance(o, r),
        p = -d * h,
        u = d * c,
        g = p * p - u * u,
        m = 2 * p * u,
        v = u * u - p * p,
        y = a[0] - s[0],
        f = a[1] - s[1],
        C = s[0] + g * y + m * f,
        P = s[1] + m * y + v * f;
    else (C = r[0] + t * (o[0] - r[0])), (P = r[1] + t * (o[1] - r[1]));
    return [C, P];
  }),
  (O.PlotUtils.getBezierPoints = function (e) {
    let t = 0;
    if (e.length <= 2) return e;
    for (var i = [], n = e.length - 1, o = 0; 1 >= o; o += 0.01) {
      for (var r = (t = 0), a = 0; n >= a; a++) {
        var l = O.PlotUtils.getBinomialFactor(n, a),
          s = Math.pow(o, a),
          c = Math.pow(1 - o, n - a);
        (r += l * s * c * e[a][0]), (t += l * s * c * e[a][1]);
      }
      i.push([r, t]);
    }
    return i.push(e[n]), i;
  }),
  (O.PlotUtils.getBinomialFactor = function (e, t) {
    return (
      O.PlotUtils.getFactorial(e) /
      (O.PlotUtils.getFactorial(t) * O.PlotUtils.getFactorial(e - t))
    );
  }),
  (O.PlotUtils.getFactorial = function (e) {
    if (1 >= e) return 1;
    if (2 == e) return 2;
    if (3 == e) return 6;
    if (4 == e) return 24;
    if (5 == e) return 120;
    for (var t = 1, i = 1; e >= i; i++) t *= i;
    return t;
  }),
  (O.PlotUtils.getQBSplinePoints = function (e) {
    if (e.length <= 2) return e;
    var t = [],
      i = e.length - 2 - 1;
    t.push(e[0]);
    let n = 0;
    for (var o = 0; i >= o; o++)
      for (var r = 0; 1 >= r; r += 0.05) {
        for (var a = (n = 0), l = 0; 2 >= l; l++) {
          var s = O.PlotUtils.getQuadricBSplineFactor(l, r);
          (a += s * e[o + l][0]), (n += s * e[o + l][1]);
        }
        t.push([a, n]);
      }
    return t.push(e[e.length - 1]), t;
  }),
  (O.PlotUtils.getQuadricBSplineFactor = function (e, t) {
    return 0 == e
      ? Math.pow(t - 1, 2) / 2
      : 1 == e
      ? (-2 * Math.pow(t, 2) + 2 * t + 1) / 2
      : 2 == e
      ? Math.pow(t, 2) / 2
      : 0;
  }),
  (O.Constants = {
    TWO_PI: 2 * Math.PI,
    HALF_PI: Math.PI / 2,
    FITTING_COUNT: 100,
    ZERO_TOLERANCE: 1e-4,
  });
let B = { version: "1.0.0", createTime: "2018.6.19", author: "xupinhui" };
var G = "doublearrow",
  W = 0.25,
  N = 0.3,
  z = 0.85,
  V = 0.15,
  K = {
    headHeightFactor: 0.18,
    headWidthFactor: 0.3,
    neckHeightFactor: 0.85,
    neckWidthFactor: 0.15,
    tailWidthFactor: 0.1,
    headTailFactor: 0.8,
    swallowTailFactor: 1,
  },
  Z = {
    tailWidthFactor: 0.15,
    neckWidthFactor: 0.2,
    headWidthFactor: 0.25,
    headAngle: Math.PI / 8.5,
    neckAngle: Math.PI / 13,
  };
(B.algorithm = {}),
  (B.algorithm.doubleArrow = function (t) {
    (this.connPoint = null), (this.tempPoint4 = null), (this.points = t);
    var i = { controlPoint: null, polygonalPoint: null };
    if (!(2 > (s = t.length))) {
      if (2 == s) return t;
      var n,
        o,
        r = this.points[0],
        a = this.points[1],
        l = this.points[2],
        s = t.length;
      (this.tempPoint4 =
        3 == s ? B.algorithm.getTempPoint4(r, a, l) : this.points[3]),
        (this.connPoint =
          3 == s || 4 == s ? O.PlotUtils.mid(r, a) : this.points[4]),
        O.PlotUtils.isClockWise(r, a, l)
          ? ((n = B.algorithm.getArrowPoints(
              r,
              this.connPoint,
              this.tempPoint4,
              !1
            )),
            (o = B.algorithm.getArrowPoints(this.connPoint, a, l, !0)))
          : ((n = B.algorithm.getArrowPoints(a, this.connPoint, l, !1)),
            (o = B.algorithm.getArrowPoints(
              this.connPoint,
              r,
              this.tempPoint4,
              !0
            )));
      var c = n.length,
        h = (c - 5) / 2,
        d = n.slice(0, h),
        p = n.slice(h, h + 5),
        u = n.slice(h + 5, c),
        g = o.slice(0, h),
        m = o.slice(h, h + 5),
        v = o.slice(h + 5, c);
      g = O.PlotUtils.getBezierPoints(g);
      var y = O.PlotUtils.getBezierPoints(v.concat(d.slice(1)));
      u = O.PlotUtils.getBezierPoints(u);
      var f = g.concat(m, y, p, u),
        C = B.algorithm.array2Dto1D(f);
      (i.controlPoint = [r, a, l, this.tempPoint4, this.connPoint]),
        (i.polygonalPoint = e.Cartesian3.fromDegreesArray(C));
    }
    return i;
  }),
  (B.algorithm.threeArrow = function (t) {
    (this.connPoint = null),
      (this.tempPoint4 = null),
      (this.tempPoint5 = null),
      (this.points = t);
    var i = { controlPoint: null, polygonalPoint: null };
    if ((n = t.length) >= 2) {
      if (2 == n) return t;
      var n,
        o,
        r,
        a = this.points[0],
        l = this.points[1],
        s = this.points[2];
      3 == (n = t.length)
        ? ((this.tempPoint4 = B.algorithm.getTempPoint4(a, l, s)),
          (this.tempPoint5 = O.PlotUtils.mid(s, this.tempPoint4)))
        : ((this.tempPoint4 = this.points[3]),
          (this.tempPoint5 = this.points[4])),
        (this.connPoint = n < 6 ? O.PlotUtils.mid(a, l) : this.points[5]),
        O.PlotUtils.isClockWise(a, l, s)
          ? ((o = B.algorithm.getArrowPoints(
              a,
              this.connPoint,
              this.tempPoint4,
              !1
            )),
            (r = B.algorithm.getArrowPoints(this.connPoint, l, s, !0)))
          : ((o = B.algorithm.getArrowPoints(l, this.connPoint, s, !1)),
            (r = B.algorithm.getArrowPoints(
              this.connPoint,
              a,
              this.tempPoint4,
              !0
            )));
      var c = o.length,
        h = (c - 5) / 2,
        d = o.slice(0, h),
        p = o.slice(h, h + 5),
        u = o.slice(h + 5, c),
        g = r.slice(0, h),
        m = r.slice(h, h + 5),
        v = r.slice(h + 5, c);
      g = O.PlotUtils.getBezierPoints(g);
      var y = O.PlotUtils.getBezierPoints(v.concat(d.slice(1)));
      u = O.PlotUtils.getBezierPoints(u);
      var f = g.concat(m, y, p, u),
        C = B.algorithm.array2Dto1D(f);
      (i.controlPoint = [
        a,
        l,
        s,
        this.tempPoint4,
        this.tempPoint5,
        this.connPoint,
      ]),
        (i.polygonalPoint = e.Cartesian3.fromDegreesArray(C));
    }
    return i;
  }),
  (B.algorithm.array2Dto1D = function (e) {
    var t = [];
    return (
      e.forEach(function (e) {
        t.push(e[0]), t.push(e[1]);
      }),
      t
    );
  }),
  (B.algorithm.getArrowPoints = function (e, t, i, n) {
    (this.type = G),
      (this.headHeightFactor = W),
      (this.headWidthFactor = N),
      (this.neckHeightFactor = z),
      (this.neckWidthFactor = V);
    var o = O.PlotUtils.mid(e, t),
      r = O.PlotUtils.distance(o, i),
      a = O.PlotUtils.getThirdPoint(i, o, 0, 0.3 * r, !0),
      l = O.PlotUtils.getThirdPoint(i, o, 0, 0.5 * r, !0),
      s = [
        o,
        (a = O.PlotUtils.getThirdPoint(o, a, O.Constants.HALF_PI, r / 5, n)),
        (l = O.PlotUtils.getThirdPoint(o, l, O.Constants.HALF_PI, r / 4, n)),
        i,
      ],
      c = B.algorithm.getArrowHeadPoints(
        s,
        this.headHeightFactor,
        this.headWidthFactor,
        this.neckHeightFactor,
        this.neckWidthFactor
      ),
      h = c[0],
      d = c[4],
      p = O.PlotUtils.distance(e, t) / O.PlotUtils.getBaseLength(s) / 2,
      u = B.algorithm.getArrowBodyPoints(s, h, d, p),
      g = u.length,
      m = u.slice(0, g / 2),
      v = u.slice(g / 2, g);
    return (
      m.push(h),
      v.push(d),
      (m = m.reverse()).push(t),
      (v = v.reverse()).push(e),
      m.reverse().concat(c, v)
    );
  }),
  (B.algorithm.getArrowHeadPoints = function (e, t, i) {
    (this.type = G),
      (this.headHeightFactor = W),
      (this.headWidthFactor = N),
      (this.neckHeightFactor = z),
      (this.neckWidthFactor = V);
    var n = O.PlotUtils.getBaseLength(e) * this.headHeightFactor,
      o = e[e.length - 1],
      r = (O.PlotUtils.distance(t, i), n * this.headWidthFactor),
      a = n * this.neckWidthFactor,
      l = n * this.neckHeightFactor,
      s = O.PlotUtils.getThirdPoint(e[e.length - 2], o, 0, n, !0),
      c = O.PlotUtils.getThirdPoint(e[e.length - 2], o, 0, l, !0),
      h = O.PlotUtils.getThirdPoint(o, s, O.Constants.HALF_PI, r, !1),
      d = O.PlotUtils.getThirdPoint(o, s, O.Constants.HALF_PI, r, !0);
    return [
      O.PlotUtils.getThirdPoint(o, c, O.Constants.HALF_PI, a, !1),
      h,
      o,
      d,
      O.PlotUtils.getThirdPoint(o, c, O.Constants.HALF_PI, a, !0),
    ];
  }),
  (B.algorithm.getArrowBodyPoints = function (e, t, i, n) {
    for (
      var o = O.PlotUtils.wholeDistance(e),
        r = O.PlotUtils.getBaseLength(e) * n,
        a = (r - O.PlotUtils.distance(t, i)) / 2,
        l = 0,
        s = [],
        c = [],
        h = 1;
      h < e.length - 1;
      h++
    ) {
      var d = O.PlotUtils.getAngleOfThreePoints(e[h - 1], e[h], e[h + 1]) / 2,
        p =
          (r / 2 - ((l += O.PlotUtils.distance(e[h - 1], e[h])) / o) * a) /
          Math.sin(d),
        u = O.PlotUtils.getThirdPoint(e[h - 1], e[h], Math.PI - d, p, !0),
        g = O.PlotUtils.getThirdPoint(e[h - 1], e[h], d, p, !1);
      s.push(u), c.push(g);
    }
    return s.concat(c);
  }),
  (B.algorithm.getTempPoint4 = function (e, t, i) {
    var n,
      o,
      r,
      a,
      l = O.PlotUtils.mid(e, t),
      s = O.PlotUtils.distance(l, i),
      c = O.PlotUtils.getAngleOfThreePoints(e, l, i);
    return (
      c < O.Constants.HALF_PI
        ? ((o = s * Math.sin(c)),
          (r = s * Math.cos(c)),
          (a = O.PlotUtils.getThirdPoint(e, l, O.Constants.HALF_PI, o, !1)),
          (n = O.PlotUtils.getThirdPoint(l, a, O.Constants.HALF_PI, r, !0)))
        : c >= O.Constants.HALF_PI && c < Math.PI
        ? ((o = s * Math.sin(Math.PI - c)),
          (r = s * Math.cos(Math.PI - c)),
          (a = O.PlotUtils.getThirdPoint(e, l, O.Constants.HALF_PI, o, !1)),
          (n = O.PlotUtils.getThirdPoint(l, a, O.Constants.HALF_PI, r, !1)))
        : c >= Math.PI && c < 1.5 * Math.PI
        ? ((o = s * Math.sin(c - Math.PI)),
          (r = s * Math.cos(c - Math.PI)),
          (a = O.PlotUtils.getThirdPoint(e, l, O.Constants.HALF_PI, o, !0)),
          (n = O.PlotUtils.getThirdPoint(l, a, O.Constants.HALF_PI, r, !0)))
        : ((o = s * Math.sin(2 * Math.PI - c)),
          (r = s * Math.cos(2 * Math.PI - c)),
          (a = O.PlotUtils.getThirdPoint(e, l, O.Constants.HALF_PI, o, !0)),
          (n = O.PlotUtils.getThirdPoint(l, a, O.Constants.HALF_PI, r, !1))),
      n
    );
  }),
  (B.algorithm.tailedAttackArrow = function (t) {
    (t = B.algorithm.dereplication(t)),
      (this.tailWidthFactor = K.tailWidthFactor),
      (this.swallowTailFactor = K.swallowTailFactor),
      (this.swallowTailPnt = K.swallowTailPnt);
    var i = { controlPoint: null, polygonalPoint: null };
    if (((i.controlPoint = t), !(2 > (m = t.length)))) {
      if (2 == t.length) return (i.polygonalPoint = t), i;
      var n = t,
        o = n[0],
        r = n[1];
      O.PlotUtils.isClockWise(n[0], n[1], n[2]) && ((o = n[1]), (r = n[0]));
      var a = [O.PlotUtils.mid(o, r)].concat(n.slice(2)),
        l = B.algorithm.getAttackArrowHeadPoints(a, o, r, K),
        s = l[0],
        c = l[4],
        h = O.PlotUtils.distance(o, r),
        d = O.PlotUtils.getBaseLength(a),
        p = d * this.tailWidthFactor * this.swallowTailFactor;
      this.swallowTailPnt = O.PlotUtils.getThirdPoint(a[1], a[0], 0, p, !0);
      var u = h / d,
        g = B.algorithm.getAttackArrowBodyPoints(a, s, c, u),
        m = g.length,
        v = [o].concat(g.slice(0, m / 2));
      v.push(s);
      var y,
        f = [r].concat(g.slice(m / 2, m));
      f.push(c),
        (v = O.PlotUtils.getQBSplinePoints(v)),
        (f = O.PlotUtils.getQBSplinePoints(f)),
        (y = B.algorithm.array2Dto1D(
          v.concat(l, f.reverse(), [this.swallowTailPnt, v[0]])
        )),
        (i.polygonalPoint = e.Cartesian3.fromDegreesArray(y));
    }
    return i;
  }),
  (B.algorithm.getAttackArrowHeadPoints = function (e, t, i, n) {
    (this.headHeightFactor = n.headHeightFactor),
      (this.headTailFactor = n.headTailFactor),
      (this.headWidthFactor = n.headWidthFactor),
      (this.neckWidthFactor = n.neckWidthFactor),
      (this.neckHeightFactor = n.neckHeightFactor);
    var o = O.PlotUtils.getBaseLength(e),
      r = o * this.headHeightFactor,
      a = e[e.length - 1];
    o = O.PlotUtils.distance(a, e[e.length - 2]);
    var l = O.PlotUtils.distance(t, i);
    r > l * this.headTailFactor && (r = l * this.headTailFactor);
    var s = r * this.headWidthFactor,
      c = r * this.neckWidthFactor,
      h = (r = r > o ? o : r) * this.neckHeightFactor,
      d = O.PlotUtils.getThirdPoint(e[e.length - 2], a, 0, r, !0),
      p = O.PlotUtils.getThirdPoint(e[e.length - 2], a, 0, h, !0),
      u = O.PlotUtils.getThirdPoint(a, d, O.Constants.HALF_PI, s, !1),
      g = O.PlotUtils.getThirdPoint(a, d, O.Constants.HALF_PI, s, !0);
    return [
      O.PlotUtils.getThirdPoint(a, p, O.Constants.HALF_PI, c, !1),
      u,
      a,
      g,
      O.PlotUtils.getThirdPoint(a, p, O.Constants.HALF_PI, c, !0),
    ];
  }),
  (B.algorithm.getAttackArrowBodyPoints = function (e, t, i, n) {
    for (
      var o = O.PlotUtils.wholeDistance(e),
        r = O.PlotUtils.getBaseLength(e) * n,
        a = (r - O.PlotUtils.distance(t, i)) / 2,
        l = 0,
        s = [],
        c = [],
        h = 1;
      h < e.length - 1;
      h++
    ) {
      var d = O.PlotUtils.getAngleOfThreePoints(e[h - 1], e[h], e[h + 1]) / 2,
        p =
          (r / 2 - ((l += O.PlotUtils.distance(e[h - 1], e[h])) / o) * a) /
          Math.sin(d),
        u = O.PlotUtils.getThirdPoint(e[h - 1], e[h], Math.PI - d, p, !0),
        g = O.PlotUtils.getThirdPoint(e[h - 1], e[h], d, p, !1);
      s.push(u), c.push(g);
    }
    return s.concat(c);
  }),
  (B.algorithm.dereplication = function (e) {
    var t = e[e.length - 1],
      i = !1,
      n = [];
    return (
      (n = e.filter(function (e) {
        if (e[0] != t[0] && e[1] != t[1]) return e;
        i = !0;
      })),
      i && n.push(t),
      n
    );
  }),
  (B.algorithm.fineArrow = function (t, i) {
    if (t.length < 2 || i.length < 2) return;
    let n = Z.tailWidthFactor,
      o = Z.neckWidthFactor,
      r = Z.headWidthFactor,
      a = Z.headAngle,
      l = Z.neckAngle;
    var s = [];
    (s[0] = t), (s[1] = i);
    let c = s[0],
      h = s[1],
      d = O.PlotUtils.getBaseLength(s),
      p = d * n,
      u = d * o,
      g = d * r,
      m = O.PlotUtils.getThirdPoint(h, c, O.Constants.HALF_PI, p, !0),
      v = O.PlotUtils.getThirdPoint(h, c, O.Constants.HALF_PI, p, !1),
      y = O.PlotUtils.getThirdPoint(c, h, a, g, !1),
      f = O.PlotUtils.getThirdPoint(c, h, a, g, !0),
      C = O.PlotUtils.getThirdPoint(c, h, l, u, !1),
      P = O.PlotUtils.getThirdPoint(c, h, l, u, !0),
      A = [];
    return (
      A.push(
        m[0],
        m[1],
        C[0],
        C[1],
        y[0],
        y[1],
        h[0],
        h[1],
        f[0],
        f[1],
        P[0],
        P[1],
        v[0],
        v[1],
        c[0],
        c[1]
      ),
      e.Cartesian3.fromDegreesArray(A)
    );
  });
const Y = {
    militaryPlottingGatherHandler: null,
    militaryPlottingGatherPoints: [],
    endMilitaryPlottingGatherDeal() {
      (document.getElementById(this.cesiumID).style.cursor = "default"),
        this.militaryPlottingGatherHandler &&
          (this.militaryPlottingGatherHandler.destroy(),
          (this.militaryPlottingGatherHandler = null)),
        this.closeMouseTip();
      for (var e = 0; e < this.militaryPlottingGatherPoints.length; e++)
        this.viewer.entities.remove(this.militaryPlottingGatherPoints[e]);
      this.militaryPlottingGatherPoints = [];
    },
    addMilitaryPlotting(t, i, n) {
      let o = this,
        r = null;
      "straightArrow" == n
        ? (r = new e.CallbackProperty(function () {
            if (t.length > 1) {
              var i = t[0],
                n = t[1];
              if (o.isSimpleXYZ(i, n)) return null;
              let l = o.positionToLngLatHeight(i),
                s = o.positionToLngLatHeight(n);
              var r = B.algorithm.fineArrow([l[0], l[1]], [s[0], s[1]]),
                a = new e.PolygonHierarchy(r);
              return (a.keyPoints = [l, s]), a;
            }
            return null;
          }, !1))
        : "tailedAttackArrow" == n
        ? (r = new e.CallbackProperty(function () {
            if (t.length > 1) {
              var i = o.cartesian3ArrToLngLatHeightArr(t),
                n = B.algorithm.tailedAttackArrow(i).polygonalPoint;
              if (null == n || n.length < 3) return null;
              var r = new e.PolygonHierarchy(n);
              return (r.keyPoints = i), r;
            }
            return null;
          }, !1))
        : "doubleArrow" == n
        ? (r = new e.CallbackProperty(function () {
            if (t.length > 2) {
              var i = o.cartesian3ArrToLngLatHeightArr(t);
              o.coordinateArrDeduplication(i);
              var n = B.algorithm.doubleArrow(i).polygonalPoint;
              if (!e.defined(n)) return null;
              if (null == n || n.length < 3) return null;
              var r = new e.PolygonHierarchy(n);
              return (r.keyPoints = i), r;
            }
            return null;
          }, !1))
        : "rendezvous" == n &&
          (r = new e.CallbackProperty(function () {
            if (!(t.length < 3)) {
              var i = o.fineGatheringPlace(t);
              return new e.PolygonHierarchy(i);
            }
          }, !1));
      var a = {
        polygon: new e.PolygonGraphics({
          hierarchy: r,
          material: e.Color.fromCssColorString(i.color).withAlpha(i.alpha),
          show: !0,
        }),
      };
      return this.viewer.entities.add(a);
    },
    rendezvousGather(t, i) {
      document.getElementById(this.cesiumID).style.cursor = "crosshair";
      let n = this;
      this.openMouseTip("点击2次地图后，右击即可完成采集");
      let o = [],
        r = null,
        a = null;
      (this.militaryPlottingGatherHandler = new e.ScreenSpaceEventHandler(
        n.viewer.scene.canvas
      )),
        this.militaryPlottingGatherHandler.setInputAction(function (t) {
          var i = t.position;
          if (e.defined(i)) {
            var a = n.viewer.camera.getPickRay(i);
            if (e.defined(a)) {
              var l = n.viewer.scene.globe.pick(a, n.viewer.scene);
              if (
                e.defined(l) &&
                (0 == o.length &&
                  (o.push(l.clone()),
                  (r = x(l, n.viewer)),
                  n.militaryPlottingGatherPoints.push(r)),
                o.length <= 2)
              ) {
                let e = x(l, n.viewer);
                o.push(l), n.militaryPlottingGatherPoints.push(e);
              }
            }
          }
        }, e.ScreenSpaceEventType.LEFT_CLICK),
        this.militaryPlottingGatherHandler.setInputAction(function (t) {
          if (!(o.length < 2)) {
            var l = t.endPosition;
            if (e.defined(l)) {
              var s = n.viewer.camera.getPickRay(l);
              if (e.defined(s)) {
                var c = n.viewer.scene.globe.pick(s, n.viewer.scene);
                e.defined(c) &&
                  (a || (a = n.addMilitaryPlotting(o, i, "rendezvous")),
                  r.position.setValue(c),
                  a && (3 == o.length ? (o[1] = c) : (o.pop(), o.push(c))));
              }
            }
          }
        }, e.ScreenSpaceEventType.MOUSE_MOVE),
        this.militaryPlottingGatherHandler.setInputAction(function (e) {
          o.length > 2 &&
            ((a.FFPlotKeyPoints = n.cartesian3ArrToLngLatHeightArr(o)),
            n.endMilitaryPlottingGatherDeal(),
            n.setAttributeForEntity(a, i, "rendezvous"),
            t(a));
        }, e.ScreenSpaceEventType.RIGHT_CLICK);
    },
    doubleArrowGather(t, i) {
      document.getElementById(this.cesiumID).style.cursor = "crosshair";
      let n = this;
      this.openMouseTip("点击5次地图即可完成采集");
      let o = null,
        r = [],
        a = null;
      (this.militaryPlottingGatherHandler = new e.ScreenSpaceEventHandler(
        n.viewer.scene.canvas
      )),
        this.militaryPlottingGatherHandler.setInputAction(function (l) {
          var s = l.position;
          if (!e.defined(s)) return;
          var c = n.viewer.camera.getPickRay(s);
          if (!e.defined(c)) return;
          var h = n.viewer.scene.globe.pick(c, n.viewer.scene);
          if (!e.defined(h)) return;
          0 == r.length &&
            (r.push(h),
            (a = x(h, n.viewer)),
            (a.oid = -1),
            n.militaryPlottingGatherPoints.push(a),
            (o = n.addMilitaryPlotting(r, i, "doubleArrow"))),
            r.push(h);
          var d = r.length - 2;
          let p = x(h, n.viewer);
          (p.oid = d),
            n.militaryPlottingGatherPoints.push(p),
            r.length > 5 &&
              (r.pop(),
              n.viewer.entities.remove(a),
              (o.FFPlotKeyPoints = n.cartesian3ArrToLngLatHeightArr(r)),
              n.endMilitaryPlottingGatherDeal(),
              n.setAttributeForEntity(o, i, "doubleArrow"),
              t(o));
        }, e.ScreenSpaceEventType.LEFT_CLICK),
        this.militaryPlottingGatherHandler.setInputAction(function (t) {
          var i = t.endPosition;
          if (e.defined(i)) {
            var o = n.viewer.camera.getPickRay(i);
            if (e.defined(o)) {
              var l = n.viewer.scene.globe.pick(o, n.viewer.scene);
              e.defined(l) &&
                null != a &&
                (a.position.setValue(l), r.pop(), r.push(l));
            }
          }
        }, e.ScreenSpaceEventType.MOUSE_MOVE);
    },
    tailedAttackArrowGather(t, i) {
      this.openMouseTip("点击两次以上地图，右击完成采集"),
        (document.getElementById(this.cesiumID).style.cursor = "crosshair");
      let n = this,
        o = null,
        r = [],
        a = null;
      (this.militaryPlottingGatherHandler = new e.ScreenSpaceEventHandler(
        n.viewer.scene.canvas
      )),
        this.militaryPlottingGatherHandler.setInputAction(function (t) {
          var l = t.position;
          if (!e.defined(l)) return;
          var s = n.viewer.camera.getPickRay(l);
          if (!e.defined(s)) return;
          var c = n.viewer.scene.globe.pick(s, n.viewer.scene);
          if (!e.defined(c)) return;
          0 == r.length &&
            (r.push(c),
            (a = x(c, n.viewer)),
            (a.oid = -1),
            n.militaryPlottingGatherPoints.push(a),
            (o = n.addMilitaryPlotting(r, i, "tailedAttackArrow"))),
            r.push(c);
          var h = r.length - 2;
          let d = x(c, n.viewer);
          (d.oid = h), n.militaryPlottingGatherPoints.push(d);
        }, e.ScreenSpaceEventType.LEFT_CLICK),
        this.militaryPlottingGatherHandler.setInputAction(function (e) {
          r.length < 2 ||
            ((o.FFPlotKeyPoints = n.cartesian3ArrToLngLatHeightArr(r)),
            n.endMilitaryPlottingGatherDeal(),
            n.setAttributeForEntity(o, i, "tailedAttackArrow"),
            t(o));
        }, e.ScreenSpaceEventType.RIGHT_CLICK),
        this.militaryPlottingGatherHandler.setInputAction(function (t) {
          var i = t.endPosition;
          if (e.defined(i)) {
            var o = n.viewer.camera.getPickRay(i);
            if (e.defined(o)) {
              var l = n.viewer.scene.globe.pick(o, n.viewer.scene);
              e.defined(l) &&
                null != a &&
                (a.position.setValue(l), r.pop(), r.push(l));
            }
          }
        }, e.ScreenSpaceEventType.MOUSE_MOVE);
    },
    straightArrowGather(t, i) {
      this.openMouseTip("点击一次地图，右击完成采集"),
        (document.getElementById(this.cesiumID).style.cursor = "crosshair");
      let n = this,
        o = null,
        r = [],
        a = null;
      (this.militaryPlottingGatherHandler = new e.ScreenSpaceEventHandler(
        n.viewer.scene.canvas
      )),
        this.militaryPlottingGatherHandler.setInputAction(function (t) {
          var l = t.position;
          if (e.defined(l)) {
            var s = n.viewer.camera.getPickRay(l);
            if (e.defined(s)) {
              var c = n.viewer.scene.globe.pick(s, n.viewer.scene);
              if (e.defined(c))
                if (0 == r.length) {
                  r.push(c),
                    (a = x(c, n.viewer)),
                    (a.oid = -1),
                    n.militaryPlottingGatherPoints.push(a),
                    (o = n.addMilitaryPlotting(r, i, "straightArrow")),
                    r.push(c);
                  var h = r.length - 2;
                  let e = x(c, n.viewer);
                  (e.oid = h), n.militaryPlottingGatherPoints.push(e);
                }
            }
          }
        }, e.ScreenSpaceEventType.LEFT_CLICK),
        this.militaryPlottingGatherHandler.setInputAction(function (e) {
          var a = n.viewer.camera.getPickRay(e.position),
            l = n.viewer.scene.globe.pick(a, n.viewer.scene);
          r.push(l);
          var s = r.length - 2;
          let c = x(l, n.viewer);
          (c.oid = s),
            n.militaryPlottingGatherPoints.push(c),
            r.length > 1 &&
              (r.pop(),
              (o.FFPlotKeyPoints = n.cartesian3ArrToLngLatHeightArr(r)),
              n.endMilitaryPlottingGatherDeal(),
              n.setAttributeForEntity(o, i, "straightArrow"),
              t(o));
        }, e.ScreenSpaceEventType.RIGHT_CLICK),
        this.militaryPlottingGatherHandler.setInputAction(function (t) {
          var i = t.endPosition;
          if (e.defined(i)) {
            var o = n.viewer.camera.getPickRay(i);
            if (e.defined(o)) {
              var l = n.viewer.scene.globe.pick(o, n.viewer.scene);
              e.defined(l) &&
                null != a &&
                (a.position.setValue(l), r.pop(), r.push(l));
            }
          }
        }, e.ScreenSpaceEventType.MOUSE_MOVE);
    },
    fineGatheringPlace(t) {
      let i = this;
      if (t.length < 2) return !1;
      {
        let n = new Array();
        if (
          (t.forEach(function (e) {
            var t = i.positionToLngLatHeight(e);
            n.push([t[0], t[1]]);
          }),
          2 === n.length)
        ) {
          let e = O.PlotUtils.mid(n[0], n[1]),
            t = O.PlotUtils.distance(n[0], e) / 0.9,
            i = O.PlotUtils.getThirdPoint(n[0], e, O.Constants.HALF_PI, t, !0);
          n = [n[0], i, n[1]];
        }
        let o = O.PlotUtils.mid(n[0], n[2]);
        n.push(o, n[0], n[1]);
        let [r, a, l, s, c] = [[], void 0, void 0, void 0, []];
        for (let e = 0; e < n.length - 2; e++) {
          (a = n[e]), (l = n[e + 1]), (s = n[e + 2]);
          let t = O.PlotUtils.getBisectorNormals(0.4, a, l, s);
          r = r.concat(t);
        }
        let h = r.length;
        r = [r[h - 1]].concat(r.slice(0, h - 1));
        for (let e = 0; e < n.length - 2; e++) {
          (a = n[e]), (l = n[e + 1]), (c = c.concat(a));
          for (let t = 0; t <= O.Constants.FITTING_COUNT; t++) {
            let i = O.PlotUtils.getCubicValue(
              t / O.Constants.FITTING_COUNT,
              a,
              r[2 * e],
              r[2 * e + 1],
              l
            );
            c = c.concat(i);
          }
          c = c.concat(l);
        }
        return e.Cartesian3.fromDegreesArray(c);
      }
    },
  },
  j = {
    militaryPlottingEditHandler: null,
    militaryPlottingEditPoints: [],
    addStraightArrowEntity(e, t) {},
  },
  Q = {
    init(t, i) {
      return new e.ParticleSystem({
        image: i.url,
        startColor: e.Color.RED.withAlpha(0.1),
        endColor: e.Color.YELLOW.withAlpha(0.5),
        imageSize: new e.Cartesian2(5, 5),
        startScale: 0.5,
        endScale: i.endScale,
        minimumParticleLife: 1.5,
        maximumParticleLife: 3,
        minimumSpeed: 29,
        maximumSpeed: 30,
        emissionRate: 100,
        emitter: new e.CircleEmitter(10),
        sizeInMeters: !0,
        modelMatrix: this.computeModelMatrix({
          lng: t[0],
          lat: t[1],
          height: t[2],
        }),
        emitterModelMatrix: this.computeEmitterModelMatrix(),
      });
    },
    computeModelMatrix(t) {
      const i = e.Cartesian3.fromDegrees(t.lng, t.lat, t.height);
      return e.Transforms.eastNorthUpToFixedFrame(i);
    },
    computeEmitterModelMatrix() {
      let t = e.HeadingPitchRoll.fromDegrees(0, 0, 0),
        i = new e.TranslationRotationScale();
      return (
        (i.translation = e.Cartesian3.fromElements(0, 0, 0)),
        (i.rotation = e.Quaternion.fromHeadingPitchRoll(t)),
        e.Matrix4.fromTranslationRotationScale(i)
      );
    },
  },
  X = {
    ffCesiumCloudCollection: null,
    addCloudEffect(t) {
      return (
        this.ffCesiumCloudCollection ||
          (this.ffCesiumCloudCollection = this.viewer.scene.primitives.add(
            new e.CloudCollection({
              noiseDetail: 16,
              noiseOffset: e.Cartesian3.ZERO,
            })
          )),
        this.ffCesiumCloudCollection.add({
          position: e.Cartesian3.fromDegrees(t.lng, t.lat, t.height),
          scale: new e.Cartesian2(t.scaleX, t.scaleY),
          slice: t.slice,
          color: e.Color.fromCssColorString(t.color),
          maximumSize: new e.Cartesian3(
            t.maximumSizeX,
            t.maximumSizeY,
            t.maximumSizeZ
          ),
        })
      );
    },
    addRainEffect(t) {
      var i = new e.PostProcessStage({
        name: "FFCesium.addRainEffect",
        fragmentShader:
          "uniform sampler2D colorTexture;\n\t\t\t in vec2 v_textureCoordinates;\n       uniform float tiltAngle;\n       uniform float rainSize;\n       uniform float rainWidth;\n       uniform float rainSpeed;\n\t\t\t float hash(float x){\n\t\t\t\t\treturn fract(sin(x*233.3)*13.13);\n\t\t\t }\n       out vec4 vFragColor;\n\t\t\tvoid main(void){\n\t\t\t\tfloat time = czm_frameNumber / rainSpeed;\n\t\t\t  vec2 resolution = czm_viewport.zw;\n\t\t\t  vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\n\t\t\t  vec3 c=vec3(1.0,1.0,1.0);\n\t\t\t  float a= tiltAngle;\n\t\t\t  float si=sin(a),co=cos(a);\n\t\t\t  uv*=mat2(co,-si,si,co);\n\t\t\t  uv*=length(uv+vec2(0,4.9))*rainSize + 1.;\n\t\t\t  float v = 1.0 - abs(sin(hash(floor(uv.x * rainWidth)) * 2.0));\n\t\t\t  float b=clamp(abs(sin(20.*time*v+uv.y*(5./(2.+v))))-.95,0.,1.)*20.;\n\t\t\t  c*=v*b;\n        vFragColor = mix(texture(colorTexture, v_textureCoordinates), vec4(c,.3), .3);\n\t\t\t}\n    ",
        uniforms: {
          tiltAngle: t.tiltAngle,
          rainSize: t.rainSize,
          rainWidth: t.rainWidth,
          rainSpeed: t.rainSpeed,
        },
      });
      return this.viewer.scene.postProcessStages.add(i), i;
    },
    removeRainEffect(e) {
      this.viewer.scene.postProcessStages.remove(e);
    },
    addSnowEffect(t) {
      var i = new e.PostProcessStage({
        name: "FFCesium.addSnowEffect",
        fragmentShader:
          "uniform sampler2D colorTexture;\n    in vec2 v_textureCoordinates;\n    uniform float snowSpeed;\n    float snow(vec2 uv,float scale){\n        float time = czm_frameNumber / snowSpeed;\n        float w=smoothstep(1.,0.,-uv.y*(scale/10.));if(w<.1)return 0.;\n        uv+=time/scale;uv.y+=time*2./scale;uv.x+=sin(uv.y+time*.5)/scale;\n        uv*=scale;vec2 s=floor(uv),f=fract(uv),p;float k=3.,d;\n        p=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;d=length(p);k=min(d,k);\n        k=smoothstep(0.,k,sin(f.x+f.y)*0.01);\n        return k*w;\n    }\n    out vec4 vFragColor;\n    void main(void){\n        vec2 resolution = czm_viewport.zw;\n        vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\n        vec3 finalColor=vec3(0);\n        float c = 0.0;\n        c+=snow(uv,50.)*.0;\n        c+=snow(uv,30.)*.0;\n        c+=snow(uv,10.)*.0;\n        c+=snow(uv,5.);\n        c+=snow(uv,4.);\n        c+=snow(uv,3.);\n        c+=snow(uv,2.);\n        finalColor=(vec3(c));\n        vFragColor = mix(texture(colorTexture, v_textureCoordinates), vec4(finalColor,1), 0.3);\n    }\n    ",
        uniforms: { snowSpeed: t.snowSpeed },
      });
      return this.viewer.scene.postProcessStages.add(i), i;
    },
    removeSnowEffect(e) {
      this.viewer.scene.postProcessStages.remove(e);
    },
    addFogEffect(t) {
      var i = new e.PostProcessStage({
        name: "FFCesium.addFogEffect",
        fragmentShader:
          "float getDistance(sampler2D depthTexture, vec2 texCoords)\n    {\n        float depth = czm_unpackDepth(texture(depthTexture, texCoords));\n        if (depth == 0.0) {\n            return czm_infinity;\n        }\n        vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, depth);\n        return -eyeCoordinate.z / eyeCoordinate.w;\n    }\n    //根据距离，在中间进行插值\n    float interpolateByDistance(vec4 nearFarScalar, float distance)\n    {\n        //根据常识，雾应该是距离远，越看不清，近距离内的物体可以看清\n        //因此近距离alpha=0，远距离的alpha=1.0\n        //本例中设置可见度为200米\n        //雾特效的起始距离\n        float startDistance = nearFarScalar.x;\n        //雾特效的起始alpha值\n        float startValue = nearFarScalar.y;\n        //雾特效的结束距离\n        float endDistance = nearFarScalar.z;\n        //雾特效的结束alpha值\n        float endValue = nearFarScalar.w;\n        //根据每段距离占总长度的占比，插值alpha，距离越远，alpha值越大。插值范围0,1。\n        float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0);\n        return mix(startValue, endValue, t);\n    }\n    vec4 alphaBlend(vec4 sourceColor, vec4 destinationColor)\n    {\n        return sourceColor * vec4(sourceColor.aaa, 1.0) + destinationColor * (1.0 - sourceColor.a);\n    }\n    uniform sampler2D colorTexture;\n    uniform sampler2D depthTexture;\n    uniform vec4 fogByDistance;\n    uniform vec4 fogColor;\n    in vec2 v_textureCoordinates;\n    void main(void)\n    {\n        //获取地物距相机的距离\n        float distance = getDistance(depthTexture, v_textureCoordinates);\n        //获取场景原本的纹理颜色\n        vec4 sceneColor = texture(colorTexture, v_textureCoordinates);\n        //根据距离，对alpha进行插值\n        float blendAmount = interpolateByDistance(fogByDistance, distance);\n        //将alpha变化值代入雾的原始颜色中，并将雾与场景原始纹理进行融合\n        vec4 finalFogColor = vec4(fogColor.rgb, fogColor.a * blendAmount);\n        out_FragColor = alphaBlend(finalFogColor, sceneColor);\n    }",
        uniforms: {
          fogByDistance: new e.Cartesian4(500, 0, 4e3, t.alpha),
          fogColor: e.Color.WHITE,
        },
      });
      return this.viewer.scene.postProcessStages.add(i), i;
    },
    removeFogEffect(e) {
      this.viewer.scene.postProcessStages.remove(e);
    },
    addFireEffect(e, t) {
      let i = Q.init(e, t);
      return this.viewer.scene.primitives.add(i), i;
    },
    removeFireEffect(e) {
      this.viewer.scene.primitives.remove(e);
    },
  },
  J = {
    addWaterSurfaceEffect(t, i) {
      return this.viewer.scene.primitives.add(
        new e.Primitive({
          geometryInstances: new e.GeometryInstance({
            geometry: new e.PolygonGeometry({
              polygonHierarchy: new e.PolygonHierarchy(
                e.Cartesian3.fromDegreesArray(t.flat())
              ),
              vertexFormat: e.EllipsoidSurfaceAppearance.VERTEX_FORMAT,
            }),
          }),
          appearance: new e.EllipsoidSurfaceAppearance({
            aboveGround: !0,
            material: new e.Material({
              fabric: {
                type: "Water",
                uniforms: {
                  normalMap: e.buildModuleUrl(i.image),
                  frequency: i.frequency,
                  animationSpeed: i.animationSpeed,
                  amplitude: i.amplitude,
                },
              },
            }),
          }),
          show: !0,
        })
      );
    },
    removeWaterSurfaceEffect(e) {
      this.viewer.scene.primitives.remove(e);
    },
  };
function q(t, i, n) {
  (this._definitionChanged = new e.Event()),
    (this._color = void 0),
    (this._colorSubscription = void 0),
    (this.color = t),
    (this.duration = n),
    (this.trailImage = i),
    (this._time = new Date().getTime());
}
Object.defineProperties(q.prototype, {
  isConstant: {
    get: function () {
      return !1;
    },
  },
  definitionChanged: {
    get: function () {
      return this._definitionChanged;
    },
  },
  color: e.createPropertyDescriptor("color"),
});
var $ = "polylineType" + parseInt(1e3 * Math.random());
(q.prototype.getType = function (e) {
  return $;
}),
  (q.prototype.getValue = function (t, i) {
    return (
      e.defined(i) || (i = {}),
      (i.color = e.Property.getValueOrClonedDefault(
        this._color,
        t,
        e.Color.WHITE,
        i.color
      )),
      (i.image = this.trailImage),
      (i.time =
        ((new Date().getTime() - this._time) % this.duration) / this.duration),
      i
    );
  }),
  (q.prototype.equals = function (t) {
    return (
      this === t ||
      (t instanceof q &&
        e.Property.equals(this._color, t._color) &&
        e.Property.equals(this._image, t._image))
    );
  }),
  e.Material._materialCache.addMaterial($, {
    fabric: {
      type: $,
      uniforms: {
        color: new e.Color(1, 0, 0, 0.5),
        image: e.Material.DefaultImageId,
        time: -20,
      },
      source:
        "czm_material czm_getMaterial(czm_materialInput materialInput)\n          {\n                czm_material material = czm_getDefaultMaterial(materialInput);\n                vec2 st = materialInput.st;\n                vec4 colorImage = texture(image, vec2(fract(st.s - time), st.t));\n                material.alpha = colorImage.a * color.a;\n                material.diffuse = (colorImage.rgb+color.rgb)/2.0;\n                return material;\n          }",
    },
    translucent: function (e) {
      return !0;
    },
  });
const ee = {
    addPolylineMovePoint(e, t) {
      let n = [];
      var o = i.lineString(e),
        r = i.length(o, { units: "meters" }),
        a = null;
      a =
        r > 4e4
          ? i.lineChunk(o, 80, { units: "meters" })
          : r > 5e3
          ? i.lineChunk(o, 60, { units: "meters" })
          : r > 1e3
          ? i.lineChunk(o, 40, { units: "meters" })
          : i.lineChunk(o, 20, { units: "meters" });
      for (let e = 0; e < a.features.length; e++)
        if (e % 30 == 0 && a.features.length - e > 16) {
          let i = null;
          "entity" == t.addType
            ? ((i = this.addPolylineMovePointByEntity(a, e, t)), n.push(i))
            : ((i = this.addPolylineMovePointByPrimitive(a, e, t)), n.push(i));
        }
      return (n.addType = t.addType), n;
    },
    addPolylineMovePointByPrimitive(t, i, n) {
      let o = [
          t.features[0].geometry.coordinates[1][0],
          t.features[0].geometry.coordinates[1][1],
          n.height,
        ],
        r = this.addPointPrimitive(o, n),
        a = setInterval(() => {
          i < t.features.length - 1 ? (i += 1) : (i = 0);
          const o = t.features[i].geometry.coordinates[1][0],
            a = t.features[i].geometry.coordinates[1][1];
          r.position = e.Cartesian3.fromDegrees(o, a, n.height);
        }, 20);
      return (r.intervalTimer = a), r;
    },
    addPolylineMovePointByEntity(t, i, n) {
      let o = new e.Entity({
        position: e.Cartesian3.fromDegrees(
          t.features[0].geometry.coordinates[1][0],
          t.features[0].geometry.coordinates[1][1],
          n.height
        ),
        point: {
          pixelSize: n.pixelSize,
          color: e.Color.fromCssColorString(n.color),
        },
      });
      return (
        (o.type = "FFCesiumAddMovePoint"),
        this.viewer.entities.add(o),
        (o._position = new e.CallbackProperty(function () {
          i < t.features.length - 1 ? (i += 1) : (i = 0);
          const o = t.features[i].geometry.coordinates[1][0],
            r = t.features[i].geometry.coordinates[1][1];
          return e.Cartesian3.fromDegrees(o, r, n.height);
        }, !1)),
        o
      );
    },
    removePolylineMovePoint(e) {
      if ("entity" == e.addType)
        for (let t = 0; t < e.length; t++) this.viewer.entities.remove(e[t]);
      else
        for (let t = 0; t < e.length; t++)
          clearInterval(e[t].intervalTimer), this.removeFFPrimitive(e[t]);
      e = [];
    },
    addPolylineFlicker(e, t) {
      return "entity" == t.addType
        ? this.addPolylineFlickerByEntity(e, t)
        : this.addPolylineFlickerByPrimitive(e, t);
    },
    removePolylineFlicker(e) {
      "entity" == e.addType
        ? this.viewer.entities.remove(e)
        : (clearInterval(e.intervalTimer),
          this.viewer.scene.primitives.remove(primitive));
    },
    addPolylineFlickerByPrimitive(t, i) {
      const n = new e.GeometryInstance({
          geometry: new e.PolylineGeometry({
            positions: e.Cartesian3.fromDegreesArrayHeights(t.flat()),
            width: i.width,
          }),
        }),
        o = new e.Primitive({
          geometryInstances: n,
          appearance: new e.PolylineMaterialAppearance({
            material: new e.Material({
              fabric: {
                type: "Color",
                uniforms: { color: new e.Color.fromCssColorString(i.color) },
              },
            }),
          }),
        });
      (o.flickerFlag = 1), (o.flickerChangeFlag = "minus");
      let r = setInterval(() => {
        "plus" == o.flickerChangeFlag
          ? ((o.flickerFlag = o.flickerFlag + 0.02),
            o.flickerFlag > 1 && (o.flickerChangeFlag = "minus"))
          : "minus" == o.flickerChangeFlag &&
            ((o.flickerFlag = o.flickerFlag - 0.02),
            o.flickerFlag < 0.3 && (o.flickerChangeFlag = "plus")),
          (o.appearance.material.uniforms.color = e.Color.fromCssColorString(
            i.color
          ).withAlpha(o.flickerFlag));
      }, 20);
      return (
        (o.intervalTimer = r),
        (o.addType = i.addType),
        this.viewer.scene.primitives.add(o),
        o
      );
    },
    addPolylineFlickerByEntity(t, i) {
      let n = this.viewer.entities.add({
        show: !0,
        polyline: {
          positions: e.Cartesian3.fromDegreesArrayHeights(t.flat()),
          width: 5,
          material: e.Color.fromCssColorString(i.color),
        },
      });
      return (
        (n.flickerFlag = 1),
        (n.flickerChangeFlag = "minus"),
        (n.polyline = {
          positions: n.polyline.positions,
          width: i.width,
          material: new e.ImageMaterialProperty({
            image:
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAuCAYAAAHIPq6KAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAUKADAAQAAAABAAAALgAAAAB3AhLhAAADf0lEQVRoBe1bTWsUQRCtnqnZuIagqCzoGvTkyWs8ePcvePXknxAED4I/y7PgQS9KohdBxYAEIQY/9qN9r7MrAyHbnZ1OUrBdMDvDTHX169fV1dU9s+6l97oh4iQiujmWe16kF9ET93jfQy8uVVzlUMNtT/wTmQpgLhb30fvNkUi9WA2tfe19E1Pic700lvs4R+k5hVbvjPxzEBlvzHvvbxNsTEjPAOaqXwkNihnjc51M5eFUpA8uozBTDCazmGKMOsk+lmrQoVcewB168Igsxt0H79c0U4ewFS51RKc2WW+JXP2dqbmsVEdjuZPLZYJBdMUWLqKxicopYt8Ps/hem4rsBt32yD9DDWvtWrpcK4bdK8DEYMkj2tTy7k/GoacICrsX8oALVtxb79fnwQERNjoNZaw7yZRiyA3RJxWQOR5Jpc5QSeuJ3AUq5UyKwx5AJEtbALYGChuCPENykqrKHguTaj2BUvbIdYK6k1QLwCSaFii57bF/hOcNYkyNIWyOUcXy5M0sDlZji2Gm18gnAHQ/DYJjz2dPWxe401KPdCDyf243ORf3RdYxOMIUl2uJtxRVxxTSvyKXCZAH8v8A9Bjdc7mtMpZrQMUQQ3D2AALZdSy4mQKbi4HsMvVOhqCtwcFMxh6DCNQ3Aaw3dcJ03RzAkm7Rj7qIyYHRblAB2GZjmevC4DKstcuYZ9DtTPxTBGtutNaY8swFahUvnzELc9FegU57AJ2Xr2BuvmCyBxBbH7uVl2piNZupG9kDbc7iio6jWZEI7vPC4gAJAAEMSxGRi/wxKNlfvxhs46lCogv22+HP6gbDqbLQwbgi+m1w/DLQ0E6bzA52V6aoTkZyheTNCAxbC1YjtsVeUTA3AHkV1sTMCwOR9MIZoRYxm8LEXY8bQETyarAWSMQ1+LOXFgKTOeGr3SFQ1UhkauTVYesoeGQhMKmzzO8aJbXiHJU4ZIt0YKAQ2IE8Fi0EFgI7MtCxePHAQmBHBjoWLx7YkUB+dPkCiXP43A3nsBrB5kL4Pq+j7ZUorpiHv6ClXIHwwPa0OLglPZPLuSIRBpRvHbh04zH3PJIYKVcezxhQuNw3bl/NSGzvwhQSE9xERyrfwRTJgjMGCcTN7iWYWG0VxbdZPxDwjpBm8aMyi12lByIH88/22wAxowRS2/fK9VEGdE8Ef8w4lJR/J851y/mQgX+Q0aRPfs4pYQAAAABJRU5ErkJggg==",
            color: new e.CallbackProperty(function () {
              return (
                "plus" == n.flickerChangeFlag
                  ? ((n.flickerFlag = n.flickerFlag + 0.02),
                    n.flickerFlag > 1 && (n.flickerChangeFlag = "minus"))
                  : "minus" == n.flickerChangeFlag &&
                    ((n.flickerFlag = n.flickerFlag - 0.02),
                    n.flickerFlag < 0.3 && (n.flickerChangeFlag = "plus")),
                e.Color.fromCssColorString(i.color).withAlpha(n.flickerFlag)
              );
            }, !1),
            repeat: new e.Cartesian2(1, 1),
            transparent: !0,
          }),
        }),
        (n.addType = i.addType),
        n
      );
    },
    addPolylineFlow(t, i) {
      return this.viewer.entities.add({
        polyline: {
          positions: e.Cartesian3.fromDegreesArrayHeights(t.flat()),
          width: i.width,
          material: new q(e.Color.fromCssColorString(i.color), i.url, i.time),
        },
      });
    },
    removePolylineFlow(e) {
      this.viewer.entities.remove(e);
    },
    addLineSegmentLabel(e, t) {
      let n = [],
        o = [...t.label];
      var r = i.lineString(this.getLngLatArrFromLngLatHeightArr(e));
      let a = i.length(r, { units: "meters" }) / (o.length + 1);
      return (
        i.lineChunk(r, a, { units: "meters" }).features.forEach((e, i) => {
          if (i < o.length) {
            let r = [
                e.geometry.coordinates[e.geometry.coordinates.length - 1][0],
                e.geometry.coordinates[e.geometry.coordinates.length - 1][1],
                10,
              ],
              a = "";
            a += "<div style='" + t.styleStr + "'>" + o[i] + "</div>";
            let l = this.addHtml(r, a, t.offset);
            n.push(l);
          }
        }),
        n
      );
    },
  },
  te = {
    judgePointAndPolygon(e, t) {
      var n = i.point(e);
      t.forEach((e) => {
        e.push(e[0]);
      });
      var o = i.polygon(t);
      return !i.booleanDisjoint(n, o);
    },
    judgePolylineAndPolygon(e, t) {
      var n = i.lineString(e);
      t.forEach((e) => {
        e.push(e[0]);
      });
      var o = i.polygon(t);
      return !i.booleanDisjoint(n, o);
    },
    judgePolygonAndPolygon(e, t) {
      e.forEach((e) => {
        e.push(e[0]);
      });
      var n = i.polygon(e);
      t.forEach((e) => {
        e.push(e[0]);
      });
      var o = i.polygon(t);
      return !i.booleanDisjoint(n, o);
    },
  },
  ie = {
    addHtmlForVue(t, i, n) {
      i.removeListener && i.removeListener(), (i.style.position = "absolute");
      var o = new e.Cartesian2();
      let r = this;
      return (
        (i.removeListener = this.viewer.scene.preRender.addEventListener(
          function () {
            var a = e.Cartesian3.fromDegrees(t[0], t[1], t[2]),
              l = r.viewer.scene.cartesianToCanvasCoordinates(a, o);
            if (e.defined(l)) {
              let e = i.offsetHeight + n.top,
                t = i.offsetWidth / 2 + n.left;
              (i.style.top = l.y - e + "px"), (i.style.left = l.x - t + "px");
            }
            "none" == i.style.display &&
              window.setTimeout(() => {
                i.style.display = "block";
              }, 50);
          }
        )),
        i
      );
    },
    closeHtmlForVue(e) {
      (e.style.display = "none"), e.removeListener && e.removeListener();
    },
    openDivCollisionCheckingTimer: null,
    openDivCollisionCheckingAllHtmlOverlay: null,
    openDivCollisionCheckingOption: null,
    openDivCollisionCheckFunction: null,
    openDivCollisionChecking(e, t) {
      (this.openDivCollisionCheckingAllHtmlOverlay = e),
        (this.openDivCollisionCheckingOption = t);
      let i = this;
      (this.openDivCollisionCheckFunction = function () {
        i.openDivCollisionCheckingTimer &&
          (clearInterval(i.openDivCollisionCheckingTimer),
          (i.openDivCollisionCheckingTimer = null)),
          (i.openDivCollisionCheckingTimer = setTimeout(function () {
            i.openDivCollisionCheckingCallBack();
          }, 100));
      }),
        this.viewer.scene.camera.changed.addEventListener(
          this.openDivCollisionCheckFunction
        ),
        this.viewer.scene.camera.moveEnd.addEventListener(
          this.openDivCollisionCheckFunction
        );
    },
    openDivCollisionCheckingCallBack() {
      let t = this.openDivCollisionCheckingAllHtmlOverlay,
        i = this.openDivCollisionCheckingOption;
      t.forEach((e) => {
        (e.countFlag = !1), (e.collisionFlag = !1), (e.isHidden = !1);
      });
      const n = (e, t) => {
        let i = e.getBoundingClientRect(),
          n = t.getBoundingClientRect();
        return !(
          i.bottom < n.top ||
          i.top > n.bottom ||
          i.right < n.left ||
          i.left > n.right
        );
      };
      t.forEach((o, r) => {
        for (let a = 0; a < t.length; a++)
          if (r != a && 0 == t[a].countFlag) {
            if (1 == n(o, t[a])) {
              (o.collisionFlag = !0), (t[a].collisionFlag = !0);
              let n = e.Cartesian3.fromDegrees(
                  o.lngLatHeight[0],
                  o.lngLatHeight[1],
                  o.lngLatHeight[2]
                ),
                r = e.Cartesian3.fromDegrees(
                  t[a].lngLatHeight[0],
                  t[a].lngLatHeight[1],
                  t[a].lngLatHeight[2]
                ),
                l = this.viewer.scene.camera.position;
              e.Cartesian3.distance(n, l) > e.Cartesian3.distance(r, l)
                ? ((o.style.opacity = i.opacity),
                  (o.isHidden = !0),
                  0 == t[a].isHidden && (t[a].style.opacity = 1))
                : ((t[a].style.opacity = i.opacity),
                  (t[a].isHidden = !0),
                  0 == o.isHidden && (o.style.opacity = 1));
            }
          }
        (o.countFlag = !0), (t[r].countFlag = !0);
      }),
        t.forEach((e) => {
          0 == e.collisionFlag && (e.style.opacity = 1);
        });
    },
    closeDivCollisionChecking() {
      this.viewer.scene.camera.changed.removeEventListener(
        this.openDivCollisionCheckFunction
      ),
        this.viewer.scene.camera.moveEnd.removeEventListener(
          this.openDivCollisionCheckFunction
        ),
        this.openDivCollisionCheckingTimer &&
          (clearInterval(this.openDivCollisionCheckingTimer),
          (this.openDivCollisionCheckingTimer = null));
    },
    showMapByAreaLngLat(t) {
      (this.viewer.scene.globe.depthTestAgainstTerrain = !0),
        (this.viewer.scene.globe.baseColor = e.Color.TRANSPARENT),
        (this.viewer.scene.backgroundColor = e.Color.TRANSPARENT),
        (this.viewer.scene.skyBox.show = !1),
        (this.viewer.scene.skyAtmosphere.show = !1);
      const i = [
        new e.ClippingPolygon({ positions: e.Cartesian3.fromDegreesArray(t) }),
      ];
      (this.viewer.scene.globe.clippingPolygons =
        new e.ClippingPolygonCollection({ polygons: i })),
        (this.viewer.scene.globe.clippingPolygons.inverse = !0),
        this.viewer.entities.add({
          corridor: {
            positions: e.Cartesian3.fromDegreesArray(t),
            height: -1e3,
            width: 300,
            extrudedHeight: 10,
            cornerType: e.CornerType.MITERED,
            material: e.Color.fromCssColorString("#4ABAE9"),
          },
        });
    },
  },
  ne = {
    async getHeightAtPoint(t) {
      let i = [e.Cartographic.fromDegrees(t[0], t[1])];
      try {
        return (
          await e.sampleTerrain(this.viewer.terrainProvider, 11, i, !0)
        )[0].height;
      } catch (e) {}
    },
    getCenterPointByPolyline(e) {
      var t = i.lineString(e),
        n = i.length(t, { units: "meters" });
      let o = i.lineChunk(t, n / 2, { units: "meters" }),
        r = o.features[0].geometry.coordinates.length - 1;
      return o.features[0].geometry.coordinates[r];
    },
    countlength(e) {
      let t = 0;
      if ("polygon" == e.type) {
        var n = i.lineString(e.LngLatArr);
        t = 1e3 * i.length(n, { units: "kilometers" });
      } else if ("rectangle" == e.type) {
        let o = this.rectangleCoordinateToPolygonCoordinate(
          e.LngLat.east,
          e.LngLat.west,
          e.LngLat.south,
          e.LngLat.north
        );
        n = i.lineString(o);
        t = 1e3 * i.length(n, { units: "kilometers" });
      } else if ("circle" == e.type) t = 2 * Math.PI * e.radius;
      else if ("polyline" == e.type) {
        n = i.lineString(e.LngLatArr);
        t = 1e3 * i.length(n, { units: "kilometers" });
      }
      return (t = t.toFixed(2)), t;
    },
    countArea(e) {
      let t = 0;
      if ("polygon" == e.type) {
        let o = e.LngLatArr,
          r = o.length - 1;
        o[0][0] != o[r][0] && o[0][1] !== o[r][1] && o.push(o[0]);
        var n = i.polygon([o]);
        t = i.area(n);
      } else if ("rectangle" == e.type) {
        let o = this.rectangleCoordinateToPolygonCoordinate(
          e.LngLat.east,
          e.LngLat.west,
          e.LngLat.south,
          e.LngLat.north
        );
        n = i.polygon([o]);
        t = i.area(n);
      } else "circle" == e.type && (t = Math.PI * e.radius * e.radius);
      return (t = t.toFixed(2)), t;
    },
    rectangleCoordinateToPolygonCoordinate(e, t, i, n) {
      let o = [];
      return (
        o.push([t, n]),
        o.push([t, i]),
        o.push([e, i]),
        o.push([e, n]),
        o.push([t, n]),
        o
      );
    },
    getLngLatFromLngLatHeight: (e) => [e[0], e[1]],
    getLngLatArrFromLngLatHeightArr(e) {
      let t = [];
      return (
        e.forEach((e) => {
          let i = [e[0], e[1]];
          t.push(i);
        }),
        t
      );
    },
    getCenterPointFromLngLatArr(e) {
      let t = e.length - 1;
      e[0][0] != e[t][0] && e[0][1] !== e[t][1] && e.push(e[0]);
      var n = i.polygon([e]);
      return i.center(n).geometry.coordinates;
    },
    getLngLatArrFromLngLatHeightArr(e) {
      let t = [];
      return (
        e.forEach((e) => {
          let i = [];
          i.push(e[0]), i.push(e[1]), t.push(i);
        }),
        t
      );
    },
    cartesian3ArrToLngLatHeightArr(t) {
      for (var i = [], n = 0; n < t.length; n++) {
        var o = this.viewer.scene.globe.ellipsoid,
          r = new e.Cartesian3(t[n].x, t[n].y, t[n].z),
          a = o.cartesianToCartographic(r),
          l = [];
        l.push(e.Math.toDegrees(a.longitude)),
          l.push(e.Math.toDegrees(a.latitude)),
          l.push(a.height),
          i.push(l);
      }
      return i;
    },
    positionToLngLatHeight(t) {
      let i = this.viewer.scene.globe.ellipsoid.cartesianToCartographic(t),
        n = e.Math.toDegrees(i.latitude);
      return [e.Math.toDegrees(i.longitude), n, i.height];
    },
    isSimpleXYZ: (e, t) => e.x == t.x && e.y == t.y && e.z == t.z,
    coordinateArrDeduplication(e) {
      if (e && !(e.length < 2))
        for (var t = 1; t < e.length; t++) {
          var i = e[t - 1],
            n = e[t];
          n[0] == i[0] && n[1] == i[1] && (e.splice(t, 1), t--);
        }
    },
    setAttributeForEntity(t, i, n) {
      if ("point" == n) {
        let n = t.position.getValue(e.JulianDate.now()),
          o = this.positionToLngLatHeight(n);
        (t.FFType = "FFPointEntity"),
          (t.FFOption = i),
          (t.FFCoordinates = o),
          (t.FFPosition = n);
      }
      if ("billboard" == n) {
        let n = t.position.getValue(e.JulianDate.now()),
          o = this.positionToLngLatHeight(n);
        (t.FFType = "FFBillboardEntity"),
          (t.FFOption = i),
          (t.FFCoordinates = o),
          (t.FFPosition = n);
      }
      if ("polyline" == n) {
        let e = t.polyline.positions.getValue(),
          n = this.cartesian3ArrToLngLatHeightArr(e);
        (t.FFType = "FFPolylineEntity"),
          (t.FFOption = i),
          (t.FFCoordinates = n),
          (t.FFPosition = e);
      }
      if ("polygon" == n) {
        let e = t.polygon.hierarchy.getValue().positions,
          n = this.cartesian3ArrToLngLatHeightArr(e);
        (t.FFType = "FFPolygonEntity"),
          (t.FFOption = i),
          (t.FFCoordinates = n),
          (t.FFPosition = e);
      }
      if ("rectangle" == n) {
        let n = t.rectangle.coordinates.getValue(),
          o = {};
        (o.east = e.Math.toDegrees(n.east)),
          (o.west = e.Math.toDegrees(n.west)),
          (o.north = e.Math.toDegrees(n.north)),
          (o.south = e.Math.toDegrees(n.south)),
          (t.FFType = "FFRectangleEntity"),
          (t.FFOption = i),
          (t.FFCoordinates = o),
          (t.FFPosition = n);
      }
      if ("circle" == n) {
        let n = t.position.getValue(e.JulianDate.now());
        (t.FFOption = i),
          (t.FFType = "FFCircleEntity"),
          (t.FFCenterPoint = this.positionToLngLatHeight(n)),
          (t.FFRadius = t.ellipse.semiMinorAxis.getValue()),
          (t.FFPosition = n);
      }
      if (
        "straightArrow" == n ||
        "tailedAttackArrow" == n ||
        "doubleArrow" == n ||
        "rendezvous" == n
      ) {
        let e = t.polygon.hierarchy.getValue().positions,
          o = this.cartesian3ArrToLngLatHeightArr(e);
        (t.FFType = n),
          (t.FFOption = i),
          (t.FFCoordinates = o),
          (t.FFPosition = e);
      }
    },
  };
const oe = {
  addCylinder(t, i) {
    let n = (t[0] + t[3]) / 2,
      o = (t[1] + t[4]) / 2,
      r = (t[2] + t[5]) / 2,
      a = e.Cartesian3.fromDegrees(n, o, r);
    var l = e.Cartesian3.fromDegrees(t[0], t[1], t[2]),
      s = e.Cartesian3.fromDegrees(t[3], t[4], t[5]);
    let c = this.getDistance(l, s);
    var h = e.Transforms.eastNorthUpToFixedFrame(a);
    let d = (function (t, i) {
        const n = e.Cartesian3.subtract(i, t, new e.Cartesian3()),
          o = e.Cartesian3.normalize(n, new e.Cartesian3()),
          r = e.Transforms.rotationMatrixFromPositionVelocity(
            t,
            o,
            e.Ellipsoid.WGS84
          );
        return e.Matrix4.fromRotationTranslation(r, t);
      })(
        e.Cartesian3.fromDegrees(t[0], t[1], t[2]),
        e.Cartesian3.fromDegrees(t[3], t[4], t[5])
      ),
      p = (function (t) {
        var i = e.Transforms.eastNorthUpToFixedFrame(
            e.Matrix4.getTranslation(t, new e.Cartesian3()),
            e.Ellipsoid.WGS84,
            new e.Matrix4()
          ),
          n = e.Matrix4.multiply(
            e.Matrix4.inverse(i, new e.Matrix4()),
            t,
            new e.Matrix4()
          ),
          o = e.Matrix4.getMatrix3(n, new e.Matrix3()),
          r = e.Quaternion.fromRotationMatrix(o);
        return e.HeadingPitchRoll.fromQuaternion(r);
      })(d);
    p.pitch = p.pitch + 1.57 + 3.14;
    var u = e.Matrix3.fromHeadingPitchRoll(p),
      g = e.Matrix4.fromRotationTranslation(u, new e.Cartesian3(0, 0, 0));
    e.Matrix4.multiply(h, g, h);
    const m = new e.GeometryInstance({
        geometry: new e.CylinderGeometry({
          length: c,
          topRadius: i.radius,
          bottomRadius: i.radius,
          slices: i.slices,
        }),
        modelMatrix: h,
      }),
      v = new e.Primitive({
        geometryInstances: m,
        appearance: new e.EllipsoidSurfaceAppearance({
          material: e.Material.fromType("Color", {
            color: new e.Color.fromCssColorString(i.color).withAlpha(i.alpha),
          }),
        }),
      });
    return this.viewer.scene.primitives.add(v), v;
  },
  getDistance: (t, i) => e.Cartesian3.distance(t, i),
};
class re {
  Version = "V1.0.0";
  cesiumID;
  viewer;
  Cesium;
  constructor(t, i) {
    this.Cesium = e;
    new Date().getTime();
    Object.assign(re.prototype, {
      ...r,
      ...a,
      ...b,
      ...D,
      ...H,
      ..._,
      ...R,
      ...k,
      ...U,
      ...Y,
      ...j,
      ...X,
      ...J,
      ...ee,
      ...te,
      ...ie,
      ...ne,
      ...oe,
    });
    new Date().getTime();
    (this.cesiumID = t),
      i
        ? i.viewer
          ? (this.viewer = i.viewer)
          : (this.viewer = new e.Viewer(t, i))
        : this.defaultMap(),
      (this.viewer._cesiumWidget._creditContainer.style.display = "none");
    new Date().getTime();
    this.addPrimitiveInit();
  }
  defaultMap() {
    this.viewer = new e.Viewer(this.cesiumID, {
      animation: !1,
      baseLayerPicker: !1,
      fullscreenButton: !1,
      geocoder: !1,
      homeButton: !1,
      infoBox: !1,
      sceneModePicker: !1,
      scene3DOnly: !1,
      selectionIndicator: !1,
      timeline: !1,
      navigationHelpButton: !1,
      shadows: !0,
      shouldAnimate: !0,
      baseLayer: !1,
    });
    let t = this.addGaodeLayer(
      "https://webst04.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}"
    );
    return (
      this.setView({ lng: 118.135, lat: 24.339, height: 2e4, pitchRadiu: -50 }),
      t
    );
  }
  getXyEvent() {
    let t = this;
    new e.ScreenSpaceEventHandler(this.viewer.canvas).setInputAction(function (
      i
    ) {
      var n = t.viewer.camera.getPickRay(i.position),
        o = t.viewer.scene.globe.pick(n, t.viewer.scene);
      if (e.defined(o)) {
        const i = t.viewer.scene.globe.ellipsoid.cartesianToCartographic(o);
        e.Math.toDegrees(i.longitude), e.Math.toDegrees(i.latitude);
        t.viewer.scene.globe.getHeight(i);
      }
    },
    e.ScreenSpaceEventType.LEFT_CLICK);
  }
  addFFEntity(e) {
    return this.viewer.entities.add(e);
  }
  removeFFEntityArray(e) {
    e.forEach((e) => {
      this.viewer.entities.remove(e);
    });
  }
  removeFFPrimitiveArray(e) {
    e.forEach((e) => {
      this.viewer.scene.primitives.remove(e);
    });
  }
}
export { re as default };
